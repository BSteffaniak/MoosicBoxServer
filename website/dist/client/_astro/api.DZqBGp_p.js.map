{"version":3,"file":"api.DZqBGp_p.js","sources":["../../../node_modules/.pnpm/nanostores@0.9.5/node_modules/nanostores/atom/index.js","../../../node_modules/.pnpm/nanostores@0.9.5/node_modules/nanostores/lifecycle/index.js","../../../node_modules/.pnpm/@nanostores+persistent@0.9.1_nanostores@0.9.5/node_modules/@nanostores/persistent/index.js","../../../src/services/util.ts","../../../node_modules/.pnpm/solid-js@1.8.22/node_modules/solid-js/store/dist/store.js","../../../node_modules/.pnpm/@solid-primitives+storage@2.1.4_solid-js@1.8.22/node_modules/@solid-primitives/storage/dist/index.js","../../../src/services/api.ts"],"sourcesContent":["import { clean } from '../clean-stores/index.js'\n\nlet listenerQueue = []\n\nexport let atom = (initialValue, level) => {\n  let listeners = []\n  let $atom = {\n    get() {\n      if (!$atom.lc) {\n        $atom.listen(() => {})()\n      }\n      return $atom.value\n    },\n    l: level || 0,\n    lc: 0,\n    listen(listener, listenerLevel) {\n      $atom.lc = listeners.push(listener, listenerLevel || $atom.l) / 2\n\n      return () => {\n        let index = listeners.indexOf(listener)\n        if (~index) {\n          listeners.splice(index, 2)\n          if (!--$atom.lc) $atom.off()\n        }\n      }\n    },\n    notify(changedKey) {\n      let runListenerQueue = !listenerQueue.length\n      for (let i = 0; i < listeners.length; i += 2) {\n        listenerQueue.push(\n          listeners[i],\n          listeners[i + 1],\n          $atom.value,\n          changedKey,\n        )\n      }\n\n      if (runListenerQueue) {\n        for (let i = 0; i < listenerQueue.length; i += 4) {\n          let skip\n          for (let j = i + 1; !skip && (j += 4) < listenerQueue.length;) {\n            if (listenerQueue[j] < listenerQueue[i + 1]) {\n              skip = listenerQueue.push(\n               listenerQueue[i],\n               listenerQueue[i + 1],\n               listenerQueue[i + 2],\n               listenerQueue[i + 3]\n             )\n            }\n          }\n\n          if (!skip) {\n            listenerQueue[i](listenerQueue[i + 2], listenerQueue[i + 3])\n          }\n        }\n        listenerQueue.length = 0\n      }\n    },\n    off() {}, /* It will be called on last listener unsubscribing.\n                 We will redefine it in onMount and onStop. */\n    set(data) {\n      if ($atom.value !== data) {\n        $atom.value = data\n        $atom.notify()\n      }\n    },\n    subscribe(listener, listenerLevel) {\n      let unbind = $atom.listen(listener, listenerLevel)\n      listener($atom.value)\n      return unbind\n    },\n    value: initialValue\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    $atom[clean] = () => {\n      listeners = []\n      $atom.lc = 0\n      $atom.off()\n    }\n  }\n\n  return $atom\n}\n","import { clean } from '../clean-stores/index.js'\n\nconst START = 0\nconst STOP = 1\nconst SET = 2\nconst NOTIFY = 3\nconst MOUNT = 5\nconst UNMOUNT = 6\nconst ACTION = 7\nconst REVERT_MUTATION = 10\n\nexport let on = (object, listener, eventKey, mutateStore) => {\n  object.events = object.events || {}\n  if (!object.events[eventKey + REVERT_MUTATION]) {\n    object.events[eventKey + REVERT_MUTATION] = mutateStore(eventProps => {\n      // eslint-disable-next-line no-sequences\n      object.events[eventKey].reduceRight((event, l) => (l(event), event), {\n        shared: {},\n        ...eventProps\n      })\n    })\n  }\n  object.events[eventKey] = object.events[eventKey] || []\n  object.events[eventKey].push(listener)\n  return () => {\n    let currentListeners = object.events[eventKey]\n    let index = currentListeners.indexOf(listener)\n    currentListeners.splice(index, 1)\n    if (!currentListeners.length) {\n      delete object.events[eventKey]\n      object.events[eventKey + REVERT_MUTATION]()\n      delete object.events[eventKey + REVERT_MUTATION]\n    }\n  }\n}\n\nexport let onStart = ($store, listener) =>\n  on($store, listener, START, runListeners => {\n    let originListen = $store.listen\n    $store.listen = arg => {\n      if (!$store.lc && !$store.starting) {\n        $store.starting = true\n        runListeners()\n        delete $store.starting\n      }\n      return originListen(arg)\n    }\n    return () => {\n      $store.listen = originListen\n    }\n  })\n\nexport let onStop = ($store, listener) =>\n  on($store, listener, STOP, runListeners => {\n    let originOff = $store.off\n    $store.off = () => {\n      runListeners()\n      originOff()\n    }\n    return () => {\n      $store.off = originOff\n    }\n  })\n\nexport let onSet = ($store, listener) =>\n  on($store, listener, SET, runListeners => {\n    let originSet = $store.set\n    let originSetKey = $store.setKey\n    if ($store.setKey) {\n      $store.setKey = (changed, changedValue) => {\n        let isAborted\n        let abort = () => {\n          isAborted = true\n        }\n\n        runListeners({\n          abort,\n          changed,\n          newValue: { ...$store.value, [changed]: changedValue }\n        })\n        if (!isAborted) return originSetKey(changed, changedValue)\n      }\n    }\n    $store.set = newValue => {\n      let isAborted\n      let abort = () => {\n        isAborted = true\n      }\n\n      runListeners({ abort, newValue })\n      if (!isAborted) return originSet(newValue)\n    }\n    return () => {\n      $store.set = originSet\n      $store.setKey = originSetKey\n    }\n  })\n\nexport let onNotify = ($store, listener) =>\n  on($store, listener, NOTIFY, runListeners => {\n    let originNotify = $store.notify\n    $store.notify = changed => {\n      let isAborted\n      let abort = () => {\n        isAborted = true\n      }\n\n      runListeners({ abort, changed })\n      if (!isAborted) return originNotify(changed)\n    }\n    return () => {\n      $store.notify = originNotify\n    }\n  })\n\nexport let STORE_UNMOUNT_DELAY = 1000\n\nexport let onMount = ($store, initialize) => {\n  let listener = payload => {\n    let destroy = initialize(payload)\n    if (destroy) $store.events[UNMOUNT].push(destroy)\n  }\n  return on($store, listener, MOUNT, runListeners => {\n    let originListen = $store.listen\n    $store.listen = (...args) => {\n      if (!$store.lc && !$store.active) {\n        $store.active = true\n        runListeners()\n      }\n      return originListen(...args)\n    }\n\n    let originOff = $store.off\n    $store.events[UNMOUNT] = []\n    $store.off = () => {\n      originOff()\n      setTimeout(() => {\n        if ($store.active && !$store.lc) {\n          $store.active = false\n          for (let destroy of $store.events[UNMOUNT]) destroy()\n          $store.events[UNMOUNT] = []\n        }\n      }, STORE_UNMOUNT_DELAY)\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      let originClean = $store[clean]\n      $store[clean] = () => {\n        for (let destroy of $store.events[UNMOUNT]) destroy()\n        $store.events[UNMOUNT] = []\n        $store.active = false\n        originClean()\n      }\n    }\n\n    return () => {\n      $store.listen = originListen\n      $store.off = originOff\n    }\n  })\n}\n\n\nexport let onAction = ($store, listener) =>\n  on($store, listener, ACTION, runListeners => {\n    let errorListeners = {}\n    let endListeners = {}\n    let originAction = $store.action\n    $store.action = (id, actionName, args) => {\n      runListeners({\n        actionName,\n        args,\n        id,\n        onEnd: l => {\n          (endListeners[id] || (endListeners[id] = [])).push(l)\n        },\n        onError: l => {\n          (errorListeners[id] || (errorListeners[id] = [])).push(l)\n        }\n      })\n      return [\n        error => {\n          if (errorListeners[id]) {\n            for (let l of errorListeners[id]) l({ error })\n          }\n        },\n        () => {\n          if (endListeners[id]) {\n            for (let l of endListeners[id]) l()\n            delete errorListeners[id]\n            delete endListeners[id]\n          }\n        }\n      ]\n    }\n    return () => {\n      $store.action = originAction\n    }\n  })\n","import { atom, map, onMount } from 'nanostores'\n\nlet identity = a => a\nlet storageEngine = {}\nlet eventsEngine = { addEventListener() {}, removeEventListener() {} }\n\nfunction testSupport() {\n  try {\n    return typeof localStorage !== 'undefined'\n  } catch {\n    /* c8 ignore next 3 */\n    // In Privacy Mode access to localStorage will return error\n    return false\n  }\n}\nif (testSupport()) {\n  storageEngine = localStorage\n}\n\nexport let windowPersistentEvents = {\n  addEventListener(key, listener, restore) {\n    window.addEventListener('storage', listener)\n    window.addEventListener('pageshow', restore)\n  },\n  removeEventListener(key, listener, restore) {\n    window.removeEventListener('storage', listener)\n    window.removeEventListener('pageshow', restore)\n  }\n}\n\nif (typeof window !== 'undefined') {\n  eventsEngine = windowPersistentEvents\n}\n\nexport function setPersistentEngine(storage, events) {\n  storageEngine = storage\n  eventsEngine = events\n}\n\nexport function persistentAtom(name, initial = undefined, opts = {}) {\n  let encode = opts.encode || identity\n  let decode = opts.decode || identity\n\n  let store = atom(initial)\n\n  let set = store.set\n  store.set = newValue => {\n    if (typeof newValue === 'undefined') {\n      delete storageEngine[name]\n    } else {\n      storageEngine[name] = encode(newValue)\n    }\n    set(newValue)\n  }\n\n  function listener(e) {\n    if (e.key === name) {\n      if (e.newValue === null) {\n        set(undefined)\n      } else {\n        set(decode(e.newValue))\n      }\n    } else if (!storageEngine[name]) {\n      set(undefined)\n    }\n  }\n\n  function restore() {\n    store.set(storageEngine[name] ? decode(storageEngine[name]) : initial)\n  }\n\n  onMount(store, () => {\n    restore()\n    if (opts.listen !== false) {\n      eventsEngine.addEventListener(name, listener, restore)\n      return () => {\n        eventsEngine.removeEventListener(name, listener, restore)\n      }\n    }\n  })\n\n  return store\n}\n\nexport function persistentMap(prefix, initial = {}, opts = {}) {\n  let encode = opts.encode || identity\n  let decode = opts.decode || identity\n\n  let store = map()\n\n  let setKey = store.setKey\n  store.setKey = (key, newValue) => {\n    if (typeof newValue === 'undefined') {\n      if (opts.listen !== false && eventsEngine.perKey) {\n        eventsEngine.removeEventListener(prefix + key, listener, restore)\n      }\n      delete storageEngine[prefix + key]\n    } else {\n      if (\n        opts.listen !== false &&\n        eventsEngine.perKey &&\n        !(key in store.value)\n      ) {\n        eventsEngine.addEventListener(prefix + key, listener, restore)\n      }\n      storageEngine[prefix + key] = encode(newValue)\n    }\n    setKey(key, newValue)\n  }\n\n  let set = store.set\n  store.set = function (newObject) {\n    for (let key in newObject) {\n      store.setKey(key, newObject[key])\n    }\n    for (let key in store.value) {\n      if (!(key in newObject)) {\n        store.setKey(key)\n      }\n    }\n  }\n\n  function listener(e) {\n    if (!e.key) {\n      set({})\n    } else if (e.key.startsWith(prefix)) {\n      if (e.newValue === null) {\n        setKey(e.key.slice(prefix.length), undefined)\n      } else {\n        setKey(e.key.slice(prefix.length), decode(e.newValue))\n      }\n    }\n  }\n\n  function restore() {\n    let data = { ...initial }\n    for (let key in storageEngine) {\n      if (key.startsWith(prefix)) {\n        data[key.slice(prefix.length)] = decode(storageEngine[key])\n      }\n    }\n    store.set(data)\n  }\n\n  onMount(store, () => {\n    restore()\n    if (opts.listen !== false) {\n      eventsEngine.addEventListener(prefix, listener, restore)\n      return () => {\n        eventsEngine.removeEventListener(prefix, listener, restore)\n        for (let key in store.value) {\n          eventsEngine.removeEventListener(prefix + key, listener, restore)\n        }\n      }\n    }\n  })\n\n  return store\n}\n\nlet testStorage = {}\nlet testListeners = []\n\nexport function useTestStorageEngine() {\n  setPersistentEngine(testStorage, {\n    addEventListener(key, cb) {\n      testListeners.push(cb)\n    },\n    removeEventListener(key, cb) {\n      testListeners = testListeners.filter(i => i !== cb)\n    }\n  })\n}\n\nexport function setTestStorageKey(key, newValue) {\n  if (typeof newValue === 'undefined') {\n    delete testStorage[key]\n  } else {\n    testStorage[key] = newValue\n  }\n  let event = { key, newValue }\n  for (let listener of testListeners) {\n    listener(event)\n  }\n}\n\nexport function getTestStorage() {\n  return testStorage\n}\n\nexport function cleanTestStorage() {\n  for (let i in testStorage) {\n    setTestStorageKey(i, undefined)\n  }\n}\n","import { isServer } from 'solid-js/web';\nimport type { Entries } from './types';\nimport { createSignal, onCleanup, onMount } from 'solid-js';\nimport { atom } from 'nanostores';\nimport type { WritableAtom } from 'nanostores';\nimport { persistentAtom } from '@nanostores/persistent';\n\ntype ListenerMapping<T> = {\n    baseListener: (value: T) => void;\n    listener: (value: T, prevValue: T) => void;\n};\n\nexport class ClientAtom<T> {\n    private _atom: WritableAtom<T>;\n    private _initial: T;\n    private _prevValue: T;\n    private _name: string | undefined;\n    private _listeners: ListenerMapping<T>[] = [];\n\n    constructor(initial: T, name?: string | undefined) {\n        this._initial = initial;\n        this._name = name;\n        if (name) {\n            this._atom = persistentAtom(name, initial, {\n                encode: JSON.stringify,\n                decode: JSON.parse,\n            });\n        } else {\n            this._atom = atom(initial);\n        }\n\n        this._prevValue = this.get();\n    }\n\n    get name(): string | undefined {\n        return this._name;\n    }\n\n    get initial(): T {\n        return this._initial;\n    }\n\n    get(): T {\n        return this._atom.get();\n    }\n\n    set(value: T) {\n        this._atom.set(value);\n        this._prevValue = value;\n    }\n\n    listen(listener: (value: T, prevValue: T) => void) {\n        const mapping: ListenerMapping<T> = {\n            baseListener: (v: T) => listener(v, this._prevValue),\n            listener,\n        };\n        this._atom.listen(mapping.baseListener);\n        this._listeners.push(mapping);\n    }\n\n    off(listener: (value: T, prevValue: T) => void) {\n        const index = this._listeners.findIndex((x) => x.listener === listener);\n        if (index !== -1) {\n            this._listeners.splice(index, 1);\n            this._atom.off();\n            this._listeners.forEach((mapping) => {\n                this._atom.listen(mapping.baseListener);\n            });\n        }\n    }\n}\n\nexport function clientAtom<T>(\n    initial: T,\n    name?: string | undefined,\n): ClientAtom<T> {\n    return new ClientAtom<T>(initial, name);\n}\n\nexport function clientSignal<T>(\n    atom: ClientAtom<T>,\n): [() => T, (value: T) => void] {\n    let init = true;\n\n    const [get, set] = createSignal<T>(atom.get(), {\n        equals(a, b) {\n            if (init) {\n                init = false;\n                return false;\n            }\n            return a === b;\n        },\n    });\n\n    const listener = (value: T) => {\n        set(value as Parameters<typeof set>[0]);\n    };\n\n    onMount(() => {\n        set(atom.get() as Parameters<typeof set>[0]);\n        atom.listen(listener);\n    });\n    onCleanup(() => {\n        atom.off(listener);\n    });\n\n    return [\n        () => {\n            const wasInit = init;\n            const value = get();\n\n            if (wasInit) {\n                return atom.initial;\n            } else {\n                return value;\n            }\n        },\n        (value: T) => {\n            atom.set(value);\n        },\n    ];\n}\n\ntype BaseCallbackType = (\n    ...args: any // eslint-disable-line @typescript-eslint/no-explicit-any\n) => boolean | void | Promise<boolean | void>;\nexport function createListener<CallbackType extends BaseCallbackType>(): {\n    on: (callback: CallbackType) => CallbackType;\n    onFirst: (callback: CallbackType) => CallbackType;\n    off: (callback: CallbackType) => void;\n    listeners: CallbackType[];\n    trigger: CallbackType;\n} {\n    let listeners: CallbackType[] = [];\n    function on(callback: CallbackType): CallbackType {\n        listeners.push(callback);\n        return callback;\n    }\n    function onFirst(callback: CallbackType): CallbackType {\n        listeners.unshift(callback);\n        return callback;\n    }\n    function off(callback: CallbackType): void {\n        listeners = listeners.filter((c) => c !== callback);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const trigger = (...args: any) => {\n        for (const listener of listeners) {\n            if (listener(...args) === false) {\n                break;\n            }\n        }\n    };\n\n    return { on, onFirst, off, listeners, trigger: trigger as CallbackType };\n}\n\nexport function orderedEntries<T extends Parameters<typeof Object.entries>[0]>(\n    value: T,\n    order: (keyof T)[],\n): Entries<T> {\n    const updates = Object.entries(value) as Entries<T>;\n\n    updates.sort(([key1], [key2]) => {\n        let first = order.indexOf(key1 as keyof T);\n        let second = order.indexOf(key2 as keyof T);\n        first = first === -1 ? order.length : first;\n        second = second === -1 ? order.length : second;\n\n        return first - second;\n    });\n\n    return updates;\n}\n\nexport class QueryParams {\n    private params: [string, string][];\n\n    public constructor(\n        init?: Record<string, string | undefined> | QueryParams | string,\n    ) {\n        this.params = [];\n\n        if (typeof init === 'string') {\n            if (init[0] === '?') {\n                init = init.substring(1);\n            }\n\n            if (init.trim().length > 0) {\n                init.split('&')\n                    .map((pair) => pair.split('='))\n                    .forEach(([key, value]) => {\n                        this.params.push([key!, value!]);\n                    });\n            }\n        } else if (init instanceof QueryParams) {\n            this.params.push(...init.params);\n        } else if (init) {\n            Object.entries(init).forEach(([key, value]) => {\n                if (typeof value === 'undefined') return;\n                this.params.push([key, value]);\n            });\n        }\n    }\n\n    public get size(): number {\n        return this.params.length;\n    }\n\n    public has(key: string): boolean {\n        return !!this.params.find(([k, _value]) => k === key);\n    }\n\n    public get(key: string): string | undefined {\n        const value = this.params.find(([k, _value]) => k === key);\n\n        if (value) {\n            return value[1];\n        }\n\n        return undefined;\n    }\n\n    public set(key: string, value: string) {\n        const existing = this.params.find(([k, _value]) => k === key);\n\n        if (existing) {\n            existing[1] = value;\n        } else {\n            this.params.push([key, value]);\n        }\n    }\n\n    public delete(key: string) {\n        this.params = this.params.filter(([k, _value]) => k !== key);\n    }\n\n    public forEach(func: (key: string, value: string) => void) {\n        this.params.forEach(([key, value]) => func(key, value));\n    }\n\n    public toString(): string {\n        return `${this.params\n            .map(\n                ([key, value]) =>\n                    `${encodeURIComponent(key)}=${encodeURIComponent(value)}`,\n            )\n            .join('&')}`;\n    }\n}\n\nexport function getQueryParam(key: string) {\n    const url = new URL(window.location.href);\n\n    return url.searchParams.get(key);\n}\n\nexport function setQueryParam(key: string, value: string | undefined) {\n    const url = new URL(window.location.href);\n\n    if (typeof value === 'undefined') {\n        url.searchParams.delete(key);\n    } else {\n        if (url.searchParams.get(key) === value) {\n            console.debug('Query param', key, 'is already set');\n            return;\n        }\n        url.searchParams.set(key, value);\n    }\n\n    console.debug('Replacing url state with', url.toString());\n\n    window.history.replaceState({}, '', url);\n    window.Turbo.navigator.history.replace(url);\n}\n\nexport function historyBack() {\n    window.history.back();\n}\n\nexport function isMobile() {\n    if (isServer) return false;\n\n    return isUserAgentMobile(\n        navigator.userAgent || (('opera' in window && window.opera) as string),\n    );\n}\n\nexport function isUserAgentMobile(userAgent: string | null | undefined) {\n    if (!userAgent) return false;\n\n    return (\n        /(android|bb\\d+|meego).+mobile|avantgo|bada\\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(\n            userAgent,\n        ) ||\n        /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw-(n|u)|c55\\/|capi|ccwa|cdm-|cell|chtm|cldc|cmd-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc-s|devi|dica|dmob|do(c|p)o|ds(12|-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(-|_)|g1 u|g560|gene|gf-5|g-mo|go(\\.w|od)|gr(ad|un)|haie|hcit|hd-(m|p|t)|hei-|hi(pt|ta)|hp( i|ip)|hs-c|ht(c(-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i-(20|go|ma)|i230|iac( |-|\\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\\/)|klon|kpt |kwc-|kyo(c|k)|le(no|xi)|lg( g|\\/(k|l|u)|50|54|-[a-w])|libw|lynx|m1-w|m3ga|m50\\/|ma(te|ui|xo)|mc(01|21|ca)|m-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|-([1-8]|c))|phil|pire|pl(ay|uc)|pn-2|po(ck|rt|se)|prox|psio|pt-g|qa-a|qc(07|12|21|32|60|-[2-7]|i-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h-|oo|p-)|sdk\\/|se(c(-|0|1)|47|mc|nd|ri)|sgh-|shar|sie(-|m)|sk-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h-|v-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl-|tdg-|tel(i|m)|tim-|t-mo|to(pl|sh)|ts(70|m-|m3|m5)|tx-9|up(\\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas-|your|zeto|zte-/i.test(\n            userAgent.substring(0, 4),\n        )\n    );\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function areEqualShallow(a: any, b: any) {\n    for (const key in a) {\n        if (!(key in b) || a[key] !== b[key]) {\n            return false;\n        }\n    }\n    for (const key in b) {\n        if (!(key in a) || a[key] !== b[key]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfunction circularStringify(obj: object): string {\n    const getCircularReplacer = () => {\n        const seen = new WeakSet();\n        return (_key: string, value: unknown) => {\n            if (typeof value === 'object' && value !== null) {\n                if (seen.has(value)) {\n                    return '[[circular]]';\n                }\n                seen.add(value);\n            }\n            return value;\n        };\n    };\n\n    return JSON.stringify(obj, getCircularReplacer());\n}\n\nexport function objToStr(obj: unknown): string {\n    if (typeof obj === 'string') {\n        return obj;\n    } else if (typeof obj === 'undefined') {\n        return 'undefined';\n    } else if (obj === null) {\n        return 'null';\n    } else if (typeof obj === 'object') {\n        return circularStringify(obj);\n    } else {\n        return obj.toString();\n    }\n}\n\nexport const trace = console.trace;\n\nexport function throwExpression(errorMessage: string): never {\n    throw new Error(errorMessage);\n}\n\nexport function deepEqual<T>(x: T, y: T) {\n    if (x === y) {\n        return true;\n    } else if (\n        typeof x == 'object' &&\n        x != null &&\n        typeof y == 'object' &&\n        y != null\n    ) {\n        if (Object.keys(x).length != Object.keys(y).length) return false;\n\n        for (const prop in x) {\n            // eslint-disable-next-line no-prototype-builtins\n            if (y.hasOwnProperty(prop)) {\n                if (!deepEqual(x[prop], y[prop])) return false;\n            } else return false;\n        }\n\n        return true;\n    } else return false;\n}\n\nexport function onlyUnique<T>(value: T, index: number, array: T[]): boolean {\n    return array.indexOf(value) === index;\n}\n","import { $PROXY, $TRACK, getListener, batch, createSignal } from 'solid-js';\n\nconst $RAW = Symbol(\"store-raw\"),\n  $NODE = Symbol(\"store-node\"),\n  $HAS = Symbol(\"store-has\"),\n  $SELF = Symbol(\"store-self\");\nfunction wrap$1(value) {\n  let p = value[$PROXY];\n  if (!p) {\n    Object.defineProperty(value, $PROXY, {\n      value: p = new Proxy(value, proxyTraps$1)\n    });\n    if (!Array.isArray(value)) {\n      const keys = Object.keys(value),\n        desc = Object.getOwnPropertyDescriptors(value);\n      for (let i = 0, l = keys.length; i < l; i++) {\n        const prop = keys[i];\n        if (desc[prop].get) {\n          Object.defineProperty(value, prop, {\n            enumerable: desc[prop].enumerable,\n            get: desc[prop].get.bind(p)\n          });\n        }\n      }\n    }\n  }\n  return p;\n}\nfunction isWrappable(obj) {\n  let proto;\n  return obj != null && typeof obj === \"object\" && (obj[$PROXY] || !(proto = Object.getPrototypeOf(obj)) || proto === Object.prototype || Array.isArray(obj));\n}\nfunction unwrap(item, set = new Set()) {\n  let result, unwrapped, v, prop;\n  if (result = item != null && item[$RAW]) return result;\n  if (!isWrappable(item) || set.has(item)) return item;\n  if (Array.isArray(item)) {\n    if (Object.isFrozen(item)) item = item.slice(0);else set.add(item);\n    for (let i = 0, l = item.length; i < l; i++) {\n      v = item[i];\n      if ((unwrapped = unwrap(v, set)) !== v) item[i] = unwrapped;\n    }\n  } else {\n    if (Object.isFrozen(item)) item = Object.assign({}, item);else set.add(item);\n    const keys = Object.keys(item),\n      desc = Object.getOwnPropertyDescriptors(item);\n    for (let i = 0, l = keys.length; i < l; i++) {\n      prop = keys[i];\n      if (desc[prop].get) continue;\n      v = item[prop];\n      if ((unwrapped = unwrap(v, set)) !== v) item[prop] = unwrapped;\n    }\n  }\n  return item;\n}\nfunction getNodes(target, symbol) {\n  let nodes = target[symbol];\n  if (!nodes) Object.defineProperty(target, symbol, {\n    value: nodes = Object.create(null)\n  });\n  return nodes;\n}\nfunction getNode(nodes, property, value) {\n  if (nodes[property]) return nodes[property];\n  const [s, set] = createSignal(value, {\n    equals: false,\n    internal: true\n  });\n  s.$ = set;\n  return nodes[property] = s;\n}\nfunction proxyDescriptor$1(target, property) {\n  const desc = Reflect.getOwnPropertyDescriptor(target, property);\n  if (!desc || desc.get || !desc.configurable || property === $PROXY || property === $NODE) return desc;\n  delete desc.value;\n  delete desc.writable;\n  desc.get = () => target[$PROXY][property];\n  return desc;\n}\nfunction trackSelf(target) {\n  getListener() && getNode(getNodes(target, $NODE), $SELF)();\n}\nfunction ownKeys(target) {\n  trackSelf(target);\n  return Reflect.ownKeys(target);\n}\nconst proxyTraps$1 = {\n  get(target, property, receiver) {\n    if (property === $RAW) return target;\n    if (property === $PROXY) return receiver;\n    if (property === $TRACK) {\n      trackSelf(target);\n      return receiver;\n    }\n    const nodes = getNodes(target, $NODE);\n    const tracked = nodes[property];\n    let value = tracked ? tracked() : target[property];\n    if (property === $NODE || property === $HAS || property === \"__proto__\") return value;\n    if (!tracked) {\n      const desc = Object.getOwnPropertyDescriptor(target, property);\n      if (getListener() && (typeof value !== \"function\" || target.hasOwnProperty(property)) && !(desc && desc.get)) value = getNode(nodes, property, value)();\n    }\n    return isWrappable(value) ? wrap$1(value) : value;\n  },\n  has(target, property) {\n    if (property === $RAW || property === $PROXY || property === $TRACK || property === $NODE || property === $HAS || property === \"__proto__\") return true;\n    getListener() && getNode(getNodes(target, $HAS), property)();\n    return property in target;\n  },\n  set() {\n    return true;\n  },\n  deleteProperty() {\n    return true;\n  },\n  ownKeys: ownKeys,\n  getOwnPropertyDescriptor: proxyDescriptor$1\n};\nfunction setProperty(state, property, value, deleting = false) {\n  if (!deleting && state[property] === value) return;\n  const prev = state[property],\n    len = state.length;\n  if (value === undefined) {\n    delete state[property];\n    if (state[$HAS] && state[$HAS][property] && prev !== undefined) state[$HAS][property].$();\n  } else {\n    state[property] = value;\n    if (state[$HAS] && state[$HAS][property] && prev === undefined) state[$HAS][property].$();\n  }\n  let nodes = getNodes(state, $NODE),\n    node;\n  if (node = getNode(nodes, property, prev)) node.$(() => value);\n  if (Array.isArray(state) && state.length !== len) {\n    for (let i = state.length; i < len; i++) (node = nodes[i]) && node.$();\n    (node = getNode(nodes, \"length\", len)) && node.$(state.length);\n  }\n  (node = nodes[$SELF]) && node.$();\n}\nfunction mergeStoreNode(state, value) {\n  const keys = Object.keys(value);\n  for (let i = 0; i < keys.length; i += 1) {\n    const key = keys[i];\n    setProperty(state, key, value[key]);\n  }\n}\nfunction updateArray(current, next) {\n  if (typeof next === \"function\") next = next(current);\n  next = unwrap(next);\n  if (Array.isArray(next)) {\n    if (current === next) return;\n    let i = 0,\n      len = next.length;\n    for (; i < len; i++) {\n      const value = next[i];\n      if (current[i] !== value) setProperty(current, i, value);\n    }\n    setProperty(current, \"length\", len);\n  } else mergeStoreNode(current, next);\n}\nfunction updatePath(current, path, traversed = []) {\n  let part,\n    prev = current;\n  if (path.length > 1) {\n    part = path.shift();\n    const partType = typeof part,\n      isArray = Array.isArray(current);\n    if (Array.isArray(part)) {\n      for (let i = 0; i < part.length; i++) {\n        updatePath(current, [part[i]].concat(path), traversed);\n      }\n      return;\n    } else if (isArray && partType === \"function\") {\n      for (let i = 0; i < current.length; i++) {\n        if (part(current[i], i)) updatePath(current, [i].concat(path), traversed);\n      }\n      return;\n    } else if (isArray && partType === \"object\") {\n      const {\n        from = 0,\n        to = current.length - 1,\n        by = 1\n      } = part;\n      for (let i = from; i <= to; i += by) {\n        updatePath(current, [i].concat(path), traversed);\n      }\n      return;\n    } else if (path.length > 1) {\n      updatePath(current[part], path, [part].concat(traversed));\n      return;\n    }\n    prev = current[part];\n    traversed = [part].concat(traversed);\n  }\n  let value = path[0];\n  if (typeof value === \"function\") {\n    value = value(prev, traversed);\n    if (value === prev) return;\n  }\n  if (part === undefined && value == undefined) return;\n  value = unwrap(value);\n  if (part === undefined || isWrappable(prev) && isWrappable(value) && !Array.isArray(value)) {\n    mergeStoreNode(prev, value);\n  } else setProperty(current, part, value);\n}\nfunction createStore(...[store, options]) {\n  const unwrappedStore = unwrap(store || {});\n  const isArray = Array.isArray(unwrappedStore);\n  const wrappedStore = wrap$1(unwrappedStore);\n  function setStore(...args) {\n    batch(() => {\n      isArray && args.length === 1 ? updateArray(unwrappedStore, args[0]) : updatePath(unwrappedStore, args);\n    });\n  }\n  return [wrappedStore, setStore];\n}\n\nfunction proxyDescriptor(target, property) {\n  const desc = Reflect.getOwnPropertyDescriptor(target, property);\n  if (!desc || desc.get || desc.set || !desc.configurable || property === $PROXY || property === $NODE) return desc;\n  delete desc.value;\n  delete desc.writable;\n  desc.get = () => target[$PROXY][property];\n  desc.set = v => target[$PROXY][property] = v;\n  return desc;\n}\nconst proxyTraps = {\n  get(target, property, receiver) {\n    if (property === $RAW) return target;\n    if (property === $PROXY) return receiver;\n    if (property === $TRACK) {\n      trackSelf(target);\n      return receiver;\n    }\n    const nodes = getNodes(target, $NODE);\n    const tracked = nodes[property];\n    let value = tracked ? tracked() : target[property];\n    if (property === $NODE || property === $HAS || property === \"__proto__\") return value;\n    if (!tracked) {\n      const desc = Object.getOwnPropertyDescriptor(target, property);\n      const isFunction = typeof value === \"function\";\n      if (getListener() && (!isFunction || target.hasOwnProperty(property)) && !(desc && desc.get)) value = getNode(nodes, property, value)();else if (value != null && isFunction && value === Array.prototype[property]) {\n        return (...args) => batch(() => Array.prototype[property].apply(receiver, args));\n      }\n    }\n    return isWrappable(value) ? wrap(value) : value;\n  },\n  has(target, property) {\n    if (property === $RAW || property === $PROXY || property === $TRACK || property === $NODE || property === $HAS || property === \"__proto__\") return true;\n    getListener() && getNode(getNodes(target, $HAS), property)();\n    return property in target;\n  },\n  set(target, property, value) {\n    batch(() => setProperty(target, property, unwrap(value)));\n    return true;\n  },\n  deleteProperty(target, property) {\n    batch(() => setProperty(target, property, undefined, true));\n    return true;\n  },\n  ownKeys: ownKeys,\n  getOwnPropertyDescriptor: proxyDescriptor\n};\nfunction wrap(value) {\n  let p = value[$PROXY];\n  if (!p) {\n    Object.defineProperty(value, $PROXY, {\n      value: p = new Proxy(value, proxyTraps)\n    });\n    const keys = Object.keys(value),\n      desc = Object.getOwnPropertyDescriptors(value);\n    const proto = Object.getPrototypeOf(value);\n    const isClass = value !== null && typeof value === \"object\" && !Array.isArray(value) && proto !== Object.prototype;\n    if (isClass) {\n      const descriptors = Object.getOwnPropertyDescriptors(proto);\n      keys.push(...Object.keys(descriptors));\n      Object.assign(desc, descriptors);\n    }\n    for (let i = 0, l = keys.length; i < l; i++) {\n      const prop = keys[i];\n      if (isClass && prop === \"constructor\") continue;\n      if (desc[prop].get) {\n        const get = desc[prop].get.bind(p);\n        Object.defineProperty(value, prop, {\n          get,\n          configurable: true\n        });\n      }\n      if (desc[prop].set) {\n        const og = desc[prop].set,\n          set = v => batch(() => og.call(p, v));\n        Object.defineProperty(value, prop, {\n          set,\n          configurable: true\n        });\n      }\n    }\n  }\n  return p;\n}\nfunction createMutable(state, options) {\n  const unwrappedStore = unwrap(state || {});\n  const wrappedStore = wrap(unwrappedStore);\n  return wrappedStore;\n}\nfunction modifyMutable(state, modifier) {\n  batch(() => modifier(unwrap(state)));\n}\n\nconst $ROOT = Symbol(\"store-root\");\nfunction applyState(target, parent, property, merge, key) {\n  const previous = parent[property];\n  if (target === previous) return;\n  const isArray = Array.isArray(target);\n  if (property !== $ROOT && (!isWrappable(target) || !isWrappable(previous) || isArray !== Array.isArray(previous) || key && target[key] !== previous[key])) {\n    setProperty(parent, property, target);\n    return;\n  }\n  if (isArray) {\n    if (target.length && previous.length && (!merge || key && target[0] && target[0][key] != null)) {\n      let i, j, start, end, newEnd, item, newIndicesNext, keyVal;\n      for (start = 0, end = Math.min(previous.length, target.length); start < end && (previous[start] === target[start] || key && previous[start] && target[start] && previous[start][key] === target[start][key]); start++) {\n        applyState(target[start], previous, start, merge, key);\n      }\n      const temp = new Array(target.length),\n        newIndices = new Map();\n      for (end = previous.length - 1, newEnd = target.length - 1; end >= start && newEnd >= start && (previous[end] === target[newEnd] || key && previous[start] && target[start] && previous[end][key] === target[newEnd][key]); end--, newEnd--) {\n        temp[newEnd] = previous[end];\n      }\n      if (start > newEnd || start > end) {\n        for (j = start; j <= newEnd; j++) setProperty(previous, j, target[j]);\n        for (; j < target.length; j++) {\n          setProperty(previous, j, temp[j]);\n          applyState(target[j], previous, j, merge, key);\n        }\n        if (previous.length > target.length) setProperty(previous, \"length\", target.length);\n        return;\n      }\n      newIndicesNext = new Array(newEnd + 1);\n      for (j = newEnd; j >= start; j--) {\n        item = target[j];\n        keyVal = key && item ? item[key] : item;\n        i = newIndices.get(keyVal);\n        newIndicesNext[j] = i === undefined ? -1 : i;\n        newIndices.set(keyVal, j);\n      }\n      for (i = start; i <= end; i++) {\n        item = previous[i];\n        keyVal = key && item ? item[key] : item;\n        j = newIndices.get(keyVal);\n        if (j !== undefined && j !== -1) {\n          temp[j] = previous[i];\n          j = newIndicesNext[j];\n          newIndices.set(keyVal, j);\n        }\n      }\n      for (j = start; j < target.length; j++) {\n        if (j in temp) {\n          setProperty(previous, j, temp[j]);\n          applyState(target[j], previous, j, merge, key);\n        } else setProperty(previous, j, target[j]);\n      }\n    } else {\n      for (let i = 0, len = target.length; i < len; i++) {\n        applyState(target[i], previous, i, merge, key);\n      }\n    }\n    if (previous.length > target.length) setProperty(previous, \"length\", target.length);\n    return;\n  }\n  const targetKeys = Object.keys(target);\n  for (let i = 0, len = targetKeys.length; i < len; i++) {\n    applyState(target[targetKeys[i]], previous, targetKeys[i], merge, key);\n  }\n  const previousKeys = Object.keys(previous);\n  for (let i = 0, len = previousKeys.length; i < len; i++) {\n    if (target[previousKeys[i]] === undefined) setProperty(previous, previousKeys[i], undefined);\n  }\n}\nfunction reconcile(value, options = {}) {\n  const {\n      merge,\n      key = \"id\"\n    } = options,\n    v = unwrap(value);\n  return state => {\n    if (!isWrappable(state) || !isWrappable(v)) return v;\n    const res = applyState(v, {\n      [$ROOT]: state\n    }, $ROOT, merge, key);\n    return res === undefined ? state : res;\n  };\n}\nconst producers = new WeakMap();\nconst setterTraps = {\n  get(target, property) {\n    if (property === $RAW) return target;\n    const value = target[property];\n    let proxy;\n    return isWrappable(value) ? producers.get(value) || (producers.set(value, proxy = new Proxy(value, setterTraps)), proxy) : value;\n  },\n  set(target, property, value) {\n    setProperty(target, property, unwrap(value));\n    return true;\n  },\n  deleteProperty(target, property) {\n    setProperty(target, property, undefined, true);\n    return true;\n  }\n};\nfunction produce(fn) {\n  return state => {\n    if (isWrappable(state)) {\n      let proxy;\n      if (!(proxy = producers.get(state))) {\n        producers.set(state, proxy = new Proxy(state, setterTraps));\n      }\n      fn(proxy);\n    }\n    return state;\n  };\n}\n\nconst DEV = undefined;\n\nexport { $RAW, DEV, createMutable, createStore, modifyMutable, produce, reconcile, unwrap };\n","import { createHydratableSignal } from '@solid-primitives/utils';\nimport { createSignal, onMount, onCleanup, createEffect, createUniqueId, untrack } from 'solid-js';\nimport { isServer } from 'solid-js/web';\nimport { reconcile } from 'solid-js/store';\n\nvar __require = /* @__PURE__ */ ((x) => typeof require !== \"undefined\" ? require : typeof Proxy !== \"undefined\" ? new Proxy(x, {\n  get: (a, b) => (typeof require !== \"undefined\" ? require : a)[b]\n}) : x)(function(x) {\n  if (typeof require !== \"undefined\")\n    return require.apply(this, arguments);\n  throw Error('Dynamic require of \"' + x + '\" is not supported');\n});\nfunction createStorage(props) {\n  const [error, setError] = createSignal();\n  const handleError = props?.throw ? (err, fallback) => {\n    setError(err instanceof Error ? err : new Error(fallback));\n    throw err;\n  } : (err, fallback) => {\n    setError(err instanceof Error ? err : new Error(fallback));\n  };\n  const apis = props?.api ? Array.isArray(props.api) ? props.api : [props.api] : [globalThis.localStorage].filter(Boolean);\n  const prefix = props?.prefix ? `${props.prefix}.` : \"\";\n  const signals = /* @__PURE__ */ new Map();\n  const store = new Proxy(\n    {},\n    {\n      get(_, key) {\n        let node = signals.get(key);\n        if (!node) {\n          node = createSignal(void 0, { equals: false });\n          signals.set(key, node);\n        }\n        node[0]();\n        const value = apis.reduce(\n          (result, api) => {\n            if (result !== null || !api) {\n              return result;\n            }\n            try {\n              return api.getItem(`${prefix}${key}`);\n            } catch (err) {\n              handleError(err, `Error reading ${prefix}${key} from ${api[\"name\"]}`);\n              return null;\n            }\n          },\n          null\n        );\n        if (value !== null && props?.deserializer) {\n          return props.deserializer(value, key, props.options);\n        }\n        return value;\n      }\n    }\n  );\n  const setter = (key, value, options) => {\n    const filteredValue = props?.serializer ? props.serializer(value, key, options ?? props.options) : value;\n    const apiKey = `${prefix}${key}`;\n    apis.forEach((api) => {\n      try {\n        api.getItem(apiKey) !== filteredValue && api.setItem(apiKey, filteredValue);\n      } catch (err) {\n        handleError(err, `Error setting ${prefix}${key} to ${filteredValue} in ${api.name}`);\n      }\n    });\n    const node = signals.get(key);\n    node && node[1]();\n  };\n  const remove = (key) => apis.forEach((api) => {\n    try {\n      api.removeItem(`${prefix}${key}`);\n    } catch (err) {\n      handleError(err, `Error removing ${prefix}${key} from ${api.name}`);\n    }\n  });\n  const clear = () => apis.forEach((api) => {\n    try {\n      api.clear();\n    } catch (err) {\n      handleError(err, `Error clearing ${api.name}`);\n    }\n  });\n  const toJSON = () => {\n    const result = {};\n    const addValue = (key, value) => {\n      if (!result.hasOwnProperty(key)) {\n        const filteredValue = value && props?.deserializer ? props.deserializer(value, key, props.options) : value;\n        if (filteredValue) {\n          result[key] = filteredValue;\n        }\n      }\n    };\n    apis.forEach((api) => {\n      if (typeof api.getAll === \"function\") {\n        let values;\n        try {\n          values = api.getAll();\n        } catch (err) {\n          handleError(err, `Error getting all values from in ${api.name}`);\n        }\n        for (const key of values) {\n          addValue(key, values[key]);\n        }\n      } else {\n        let index = 0, key;\n        try {\n          while (key = api.key(index++)) {\n            if (!result.hasOwnProperty(key)) {\n              addValue(key, api.getItem(key));\n            }\n          }\n        } catch (err) {\n          handleError(err, `Error getting all values from ${api.name}`);\n        }\n      }\n    });\n    return result;\n  };\n  props?.sync !== false && onMount(() => {\n    const listener = (ev) => {\n      let changed = false;\n      apis.forEach((api) => {\n        try {\n          if (api !== ev.storageArea && ev.key && ev.newValue !== api.getItem(ev.key)) {\n            ev.newValue ? api.setItem(ev.key, ev.newValue) : api.removeItem(ev.key);\n            changed = true;\n          }\n        } catch (err) {\n          handleError(\n            err,\n            `Error synching api ${api.name} from storage event (${ev.key}=${ev.newValue})`\n          );\n        }\n      });\n      changed && ev.key && signals.get(ev.key)?.[1]();\n    };\n    if (\"addEventListener\" in globalThis) {\n      globalThis.addEventListener(\"storage\", listener);\n      onCleanup(() => globalThis.removeEventListener(\"storage\", listener));\n    } else {\n      apis.forEach((api) => api.addEventListener?.(\"storage\", listener));\n      onCleanup(() => apis.forEach((api) => api.removeEventListener?.(\"storage\", listener)));\n    }\n  });\n  return [\n    store,\n    setter,\n    {\n      clear,\n      error,\n      remove,\n      toJSON\n    }\n  ];\n}\nfunction createAsyncStorage(props) {\n  const [error, setError] = createSignal();\n  const handleError = props?.throw ? (err, fallback) => {\n    setError(err instanceof Error ? err : new Error(fallback));\n    throw err;\n  } : (err, fallback) => {\n    setError(err instanceof Error ? err : new Error(fallback));\n  };\n  const apis = props?.api ? Array.isArray(props.api) ? props.api : [props.api] : [];\n  const prefix = props?.prefix ? `${props.prefix}.` : \"\";\n  const signals = /* @__PURE__ */ new Map();\n  const store = new Proxy({}, {\n    get(_, key) {\n      let node = signals.get(key);\n      if (!node) {\n        node = createSignal(void 0, { equals: false });\n        signals.set(key, node);\n      }\n      node[0]();\n      return apis.reduce((result, api) => {\n        if (result !== null || !api) {\n          return result;\n        }\n        let value;\n        try {\n          value = api.getItem(`${prefix}${key}`);\n        } catch (err) {\n          handleError(err, `Error getting ${prefix}${key} from ${api.name}`);\n        }\n        if (value instanceof Promise) {\n          return value.then(\n            (newValue) => newValue && props?.deserializer ? props.deserializer(newValue, key, props.options) : newValue\n          );\n        }\n        return value !== null && props?.deserializer ? Promise.resolve(props.deserializer(value, key, props.options)) : Promise.resolve(value);\n      }, null);\n    }\n  });\n  const setter = (key, value, options) => {\n    const filteredValue = props?.serializer ? props.serializer(value, key, options ?? props.options) : value;\n    return Promise.all(\n      apis.map((api) => {\n        try {\n          api.setItem(`${prefix}${key}`, filteredValue, options ?? props?.options);\n        } catch (err) {\n          handleError(err, `Error setting ${prefix}${key} to ${filteredValue} in ${api.name}`);\n        }\n      })\n    ).then(() => {\n      const node = signals.get(key);\n      node && node[1]();\n    });\n  };\n  const remove = (key) => {\n    Promise.all(\n      apis.map((api) => {\n        try {\n          api.removeItem(`${prefix}${key}`);\n        } catch (err) {\n          handleError(err, `Error removing ${prefix}${key} from ${api.name}`);\n        }\n      })\n    ).then(() => {\n      const node = signals.get(key);\n      node && node[1]();\n    });\n  };\n  const clear = () => Promise.all(\n    apis.map(async (api) => {\n      let index = 0, key;\n      while (key = await api.key(index++)) {\n        try {\n          await api.removeItem(key);\n        } catch (err) {\n          handleError(err, `Error removing ${key} from ${api.name} during clear()`);\n        }\n      }\n    })\n  ).then(() => {\n    return;\n  });\n  const toJSON = async () => {\n    const result = {};\n    const addValue = (key, value) => {\n      if (!result.hasOwnProperty(key)) {\n        const filteredValue = value && props?.deserializer ? props.deserializer(value, key, props.options) : value;\n        if (filteredValue) {\n          result[key] = filteredValue;\n        }\n      }\n    };\n    await Promise.all(\n      apis.map(async (api) => {\n        if (typeof api.getAll === \"function\") {\n          try {\n            const values = await api.getAll();\n            for (const key of values) {\n              addValue(key, values[key]);\n            }\n          } catch (err) {\n            handleError(err, `Error attempting to get all keys from ${api.name}`);\n          }\n        } else {\n          let index = 0, key;\n          try {\n            while (key = await api.key(index++)) {\n              addValue(key, await api.getItem(key));\n            }\n          } catch (err) {\n            handleError(err, `Error attempting to get all keys from ${api.name}`);\n          }\n        }\n      })\n    );\n    return result;\n  };\n  props?.sync !== false && onMount(() => {\n    const listener = (ev) => {\n      let changed = false;\n      apis.forEach(async (api) => {\n        try {\n          if (api !== ev.storageArea && ev.key && ev.newValue !== await api.getItem(ev.key)) {\n            ev.newValue ? api.setItem(ev.key, ev.newValue) : api.removeItem(ev.key);\n            changed = true;\n          }\n        } catch (err) {\n          handleError(err, \"Error attempting to sync on event\");\n        }\n      });\n      changed && ev.key && signals.get(ev.key)?.[1]();\n    };\n    if (\"addEventListener\" in globalThis) {\n      globalThis.addEventListener(\"storage\", listener);\n      onCleanup(() => globalThis.removeEventListener(\"storage\", listener));\n    } else {\n      apis.forEach((api) => api.addEventListener?.(\"storage\", listener));\n      onCleanup(() => apis.forEach((api) => api.removeEventListener?.(\"storage\", listener)));\n    }\n  });\n  return [\n    store,\n    setter,\n    {\n      remove,\n      clear,\n      error,\n      toJSON\n    }\n  ];\n}\nfunction createStorageSignal(key, initialValue, props) {\n  const [error, setError] = createSignal();\n  const apis = props?.api ? Array.isArray(props.api) ? props.api : [props.api] : [globalThis.localStorage].filter(Boolean);\n  const prefix = props?.prefix ? `${props.prefix}.` : \"\";\n  const read = () => apis.reduce((result, api) => {\n    if (result !== null || !api) {\n      return result;\n    }\n    let value = null;\n    try {\n      value = api.getItem(`${prefix}${key}`);\n    } catch (err) {\n      setError(\n        err instanceof Error ? err : new Error(`Error reading ${prefix}${key} from ${api.name}`)\n      );\n      if (props?.throw) {\n        throw err;\n      }\n    }\n    if (value !== null && props?.deserializer) {\n      return props.deserializer(value + \"\", key, props.options);\n    }\n    return value;\n  }, null);\n  const [accessor, setter] = createHydratableSignal(\n    initialValue,\n    () => read() ?? initialValue,\n    props\n  );\n  createEffect(() => {\n    const value = accessor();\n    const filteredValue = props?.serializer ? props.serializer(value, key, props.options) : value + \"\";\n    const apiKey = `${prefix}${key}`;\n    try {\n      if (value === null) {\n        apis.forEach((api) => api.getItem(apiKey) !== null && api.removeItem(apiKey));\n      } else {\n        apis.forEach(\n          (api) => api.getItem(apiKey) !== filteredValue && api.setItem(apiKey, filteredValue, props?.options)\n        );\n      }\n    } catch (err) {\n      setError(\n        err instanceof Error ? err : new Error(`Error ${value === null ? \"removing\" : \"writing\"} value`)\n      );\n      if (props?.throw) {\n        throw err;\n      }\n    }\n  });\n  const refetch = () => {\n    const value = read();\n    setter(value);\n  };\n  props?.sync !== false && onMount(() => {\n    const listener = (ev) => {\n      let changed = false;\n      try {\n        apis.forEach((api) => {\n          if (api !== ev.storageArea && ev.key && ev.newValue !== api.getItem(ev.key)) {\n            ev.newValue ? api.setItem(ev.key, ev.newValue) : api.removeItem(ev.key);\n            changed = true;\n          }\n        });\n      } catch (err) {\n        setError(err instanceof Error ? err : new Error(\"Error synching api after event\"));\n        if (props?.throw) {\n          throw err;\n        }\n      }\n      changed && refetch();\n    };\n    if (\"addEventListener\" in globalThis) {\n      globalThis.addEventListener(\"storage\", listener);\n      onCleanup(() => globalThis.removeEventListener(\"storage\", listener));\n    } else {\n      apis.forEach((api) => api.addEventListener?.(\"storage\", listener));\n      onCleanup(() => apis.forEach((api) => api.removeEventListener?.(\"storage\", listener)));\n    }\n  });\n  return [Object.assign(accessor, { error }), setter, refetch];\n}\nvar createLocalStorage = createStorage;\nvar createSessionStorage = (props) => createStorage({ ...props, api: globalThis.sessionStorage });\n\n// src/tools.ts\nvar addClearMethod = (storage) => {\n  if (typeof storage.clear === \"function\") {\n    return storage;\n  }\n  storage.clear = () => {\n    let key;\n    while (key = storage.key(0)) {\n      storage.removeItem(key);\n    }\n  };\n  return storage;\n};\n\n// src/cookies.ts\nvar cookiePropertyKeys = [\n  \"domain\",\n  \"expires\",\n  \"path\",\n  \"secure\",\n  \"httpOnly\",\n  \"maxAge\",\n  \"sameSite\"\n];\nfunction serializeCookieOptions(options) {\n  if (!options) {\n    return \"\";\n  }\n  let memo = \"\";\n  for (const key in options) {\n    if (!cookiePropertyKeys.includes(key))\n      continue;\n    const value = options[key];\n    memo += value instanceof Date ? `; ${key}=${value.toUTCString()}` : typeof value === \"boolean\" ? `; ${key}` : `; ${key}=${value}`;\n  }\n  return memo;\n}\nfunction deserializeCookieOptions(cookie, key) {\n  return cookie.match(`(^|;)\\\\s*${key}\\\\s*=\\\\s*([^;]+)`)?.pop() ?? null;\n}\nvar useRequest;\ntry {\n  useRequest = __require(\"solid-start/server\").useRequest;\n} catch (e) {\n  useRequest = () => {\n    console.warn(\n      \"It seems you attempt to use cookieStorage on the server without having solid-start installed or use vite.\"\n    );\n    return {\n      request: { headers: { get: () => \"\" } }\n    };\n  };\n}\nvar cookieStorage = addClearMethod({\n  _read: isServer ? (options) => {\n    const eventOrRequest = options?.getRequest?.() || useRequest();\n    const request = eventOrRequest && (\"request\" in eventOrRequest ? eventOrRequest.request : eventOrRequest);\n    let result = \"\";\n    if (eventOrRequest.responseHeaders) {\n      const responseHeaders = eventOrRequest.responseHeaders;\n      result += responseHeaders.get(\"Set-Cookie\")?.split(\",\").map((cookie) => !cookie.match(/\\\\w*\\\\s*=\\\\s*[^;]+/)).join(\";\") ?? \"\";\n    }\n    return `${result};${request?.headers?.get(\"Cookie\") ?? \"\"}`;\n  } : () => document.cookie,\n  _write: isServer ? (key, value, options) => {\n    if (options?.setCookie) {\n      options?.setCookie?.(key, value, options);\n      return;\n    }\n    const pageEvent = options?.getRequest?.() || useRequest();\n    if (!pageEvent.responseHeaders)\n      return;\n    const responseHeaders = pageEvent.responseHeaders;\n    const cookies = responseHeaders.get(\"Set-Cookie\")?.split(\",\").filter((cookie) => !cookie.match(`\\\\s*${key}\\\\s*=`)) ?? [];\n    cookies.push(`${key}=${value}${serializeCookieOptions(options)}`);\n    responseHeaders.set(\"Set-Cookie\", cookies.join(\",\"));\n  } : (key, value, options) => {\n    document.cookie = `${key}=${value}${serializeCookieOptions(options)}`;\n  },\n  getItem: (key, options) => deserializeCookieOptions(cookieStorage._read(options), key),\n  setItem: (key, value, options) => {\n    const oldValue = isServer ? cookieStorage.getItem(key, options) : null;\n    cookieStorage._write(key, value, options);\n    if (!isServer) {\n      const storageEvent = Object.assign(new Event(\"storage\"), {\n        key,\n        oldValue,\n        newValue: value,\n        url: globalThis.document.URL,\n        storageArea: cookieStorage\n      });\n      window.dispatchEvent(storageEvent);\n    }\n  },\n  removeItem: (key, options) => {\n    cookieStorage._write(key, \"deleted\", { ...options, expires: /* @__PURE__ */ new Date(0) });\n  },\n  key: (index, options) => {\n    let key = null;\n    let count = 0;\n    cookieStorage._read(options).replace(/(?:^|;)\\s*(.+?)\\s*=\\s*[^;]+/g, (_, found) => {\n      if (!key && found && count++ === index) {\n        key = found;\n      }\n      return \"\";\n    });\n    return key;\n  },\n  getLength: (options) => {\n    let length = 0;\n    cookieStorage._read(options).replace(/(?:^|;)\\s*.+?\\s*=\\s*[^;]+/g, (found) => {\n      length += found ? 1 : 0;\n      return \"\";\n    });\n    return length;\n  },\n  get length() {\n    return this.getLength();\n  }\n});\nvar createCookieStorage = (props) => createStorage({ ...props, api: cookieStorage });\nfunction makePersisted(signal, options = {}) {\n  const storage = options.storage || globalThis.localStorage;\n  if (!storage) {\n    return signal;\n  }\n  const storageOptions = options.storageOptions;\n  const name = options.name || `storage-${createUniqueId()}`;\n  const serialize = options.serialize || JSON.stringify.bind(JSON);\n  const deserialize = options.deserialize || JSON.parse.bind(JSON);\n  const init = storage.getItem(name, storageOptions);\n  const set = typeof signal[0] === \"function\" ? (data) => signal[1](() => deserialize(data)) : (data) => signal[1](reconcile(deserialize(data)));\n  let unchanged = true;\n  if (init instanceof Promise)\n    init.then((data) => unchanged && data && set(data));\n  else if (init)\n    set(init);\n  return [\n    signal[0],\n    typeof signal[0] === \"function\" ? (value) => {\n      const output = signal[1](value);\n      if (value)\n        storage.setItem(name, serialize(output), storageOptions);\n      else\n        storage.removeItem(name, storageOptions);\n      unchanged = false;\n      return output;\n    } : (...args) => {\n      signal[1](...args);\n      const value = serialize(untrack(() => signal[0]));\n      storage.setItem(name, value, storageOptions);\n      unchanged = false;\n    }\n  ];\n}\n\nexport { addClearMethod, cookieStorage, createAsyncStorage, createCookieStorage, createLocalStorage, createSessionStorage, createStorage, createStorageSignal, makePersisted };\n","import { createSignal } from 'solid-js';\nimport type { Setter } from 'solid-js';\nimport {\n    QueryParams,\n    clientAtom,\n    createListener,\n    objToStr,\n    throwExpression,\n} from './util';\nimport { makePersisted } from '@solid-primitives/storage';\nexport type Artist =\n    | Api.LibraryArtist\n    | Api.TidalArtist\n    | Api.QobuzArtist\n    | Api.YtArtist;\nexport type ArtistType = Artist['type'];\n\nexport type Album =\n    | Api.LibraryAlbum\n    | Api.TidalAlbum\n    | Api.QobuzAlbum\n    | Api.YtAlbum;\nexport type AlbumType = Album['type'];\n\nexport type Track =\n    | Api.LibraryTrack\n    | Api.TidalTrack\n    | Api.QobuzTrack\n    | Api.YtTrack;\nexport type TrackType = Track['type'];\n\nexport type ScanOrigin = 'LOCAL' | 'TIDAL' | 'QOBUZ' | 'YT';\nexport type ApiSource = 'LIBRARY' | 'TIDAL' | 'QOBUZ' | 'YT';\nexport type Id = string | number;\n\ntype GenericTrack = Track;\n\nexport function trackId(\n    track: Track | number | undefined,\n): string | number | undefined {\n    if (!track) return undefined;\n    if (typeof track === 'number' || typeof track === 'string') return track;\n    return 'trackId' in track\n        ? track.trackId\n        : 'id' in track\n          ? track.id\n          : undefined;\n}\n\nexport function toSessionPlaylistTrack(\n    track: Track,\n): Api.UpdateSessionPlaylistTrack {\n    if (track.type === 'LIBRARY') {\n        return {\n            id: `${track.trackId}`,\n            type: track.type,\n            data: JSON.stringify(track),\n        };\n    } else {\n        return {\n            id: `${track.id}`,\n            type: track.type,\n            data: JSON.stringify(track),\n        };\n    }\n}\n\nexport namespace Api {\n    const onSignatureTokenUpdatedListeners =\n        createListener<(url: string) => void>();\n    export const onSignatureTokenUpdated = onSignatureTokenUpdatedListeners.on;\n    export const offSignatureTokenUpdated =\n        onSignatureTokenUpdatedListeners.off;\n    const [_signatureToken, _setSignatureToken] = makePersisted(\n        createSignal('api.v2.signatureToken'),\n        {\n            name: 'signatureToken',\n        },\n    );\n    export function signatureToken(): ReturnType<typeof _signatureToken> {\n        return _signatureToken();\n    }\n    export function setSignatureToken(url: string): void {\n        if (url === _signatureToken()) {\n            return;\n        }\n        _setSignatureToken(url);\n\n        onSignatureTokenUpdatedListeners.trigger(url);\n    }\n\n    export type GlobalSearchResultType = 'ARTIST' | 'ALBUM' | 'TRACK';\n    export type GlobalSearchResult = (\n        | GlobalArtistSearchResult\n        | GlobalAlbumSearchResult\n        | GlobalTrackSearchResult\n    ) & { type: GlobalSearchResultType };\n\n    export interface GlobalArtistSearchResult {\n        type: 'ARTIST';\n        artistId: string | number;\n        title: string;\n        containsCover: boolean;\n        blur: boolean;\n    }\n\n    export interface GlobalAlbumSearchResult {\n        type: 'ALBUM';\n        artistId: string | number;\n        artist: string;\n        albumId: string | number;\n        title: string;\n        containsCover: boolean;\n        blur: boolean;\n        dateReleased: string;\n        dateAdded: string;\n        versions: AlbumVersionQuality[];\n    }\n\n    export interface GlobalTrackSearchResult {\n        type: 'TRACK';\n        artistId: string | number;\n        artist: string;\n        albumId: string | number;\n        album: string;\n        trackId: string | number;\n        title: string;\n        containsCover: boolean;\n        blur: boolean;\n        dateReleased: string;\n        dateAdded: string;\n        format: PlaybackQuality['format'];\n        bitDepth: number;\n        audioBitrate: number;\n        overallBitrate: number;\n        sampleRate: number;\n        channels: number;\n        source: TrackSource;\n    }\n\n    export enum PlayerType {\n        HOWLER = 'HOWLER',\n    }\n\n    export interface Player {\n        playerId: number;\n        audioOutputId: string;\n        name: string;\n    }\n\n    export interface Connection {\n        connectionId: string;\n        name: string;\n        alive: boolean;\n        players: Player[];\n    }\n\n    export interface LibraryArtist {\n        artistId: number;\n        title: string;\n        containsCover: boolean;\n        blur: boolean;\n        tidalId?: number;\n        qobuzId?: number;\n        type: 'LIBRARY';\n    }\n\n    export enum TrackSource {\n        LOCAL = 'LOCAL',\n        TIDAL = 'TIDAL',\n        QOBUZ = 'QOBUZ',\n        YT = 'YT',\n    }\n\n    export interface AlbumVersionQuality {\n        format: PlaybackQuality['format'] | null;\n        bitDepth: number | null;\n        sampleRate: number | null;\n        channels: number | null;\n        source: TrackSource;\n    }\n\n    export interface LibraryAlbum {\n        albumId: number;\n        title: string;\n        artist: string;\n        artistId: number;\n        containsCover: boolean;\n        blur: boolean;\n        dateReleased: string;\n        dateAdded: string;\n        versions: AlbumVersionQuality[];\n        tidalId?: number;\n        qobuzId?: string;\n        ytId?: string;\n        tidalArtistId?: number;\n        qobuzArtistId?: number;\n        ytArtistId?: string;\n        type: 'LIBRARY';\n    }\n\n    export interface LibraryTrack {\n        trackId: number;\n        number: number;\n        title: string;\n        duration: number;\n        album: string;\n        albumId: number;\n        dateReleased: string;\n        artist: string;\n        artistId: number;\n        containsCover: boolean;\n        blur: boolean;\n        bytes: number;\n        format: PlaybackQuality['format'];\n        bitDepth: number;\n        audioBitrate: number;\n        overallBitrate: number;\n        sampleRate: number;\n        channels: number;\n        type: 'LIBRARY';\n        source: ApiSource;\n    }\n\n    export interface AlbumVersion {\n        tracks: Api.LibraryTrack[];\n        format: PlaybackQuality['format'] | null;\n        bitDepth: number | null;\n        audioBitrate: number | null;\n        overallBitrate: number | null;\n        sampleRate: number | null;\n        channels: number | null;\n        source: TrackSource;\n    }\n\n    export const AudioFormat = {\n        AAC: 'AAC',\n        FLAC: 'FLAC',\n        MP3: 'MP3',\n        OPUS: 'OPUS',\n        SOURCE: 'SOURCE',\n    } as const;\n\n    export interface PlaybackQuality {\n        format: keyof typeof AudioFormat;\n    }\n\n    export interface UpdatePlaybackSession {\n        sessionId: number;\n        name?: string;\n        active?: boolean;\n        playing?: boolean;\n        position?: number;\n        seek?: number;\n        volume?: number;\n        playbackTarget?: PlaybackTarget;\n        playlist?: UpdatePlaybackSessionPlaylist;\n    }\n\n    export interface UpdatePlaybackSessionPlaylist {\n        sessionPlaylistId: number;\n        tracks: UpdateSessionPlaylistTrack[];\n    }\n\n    export interface UpdateSessionPlaylistTrack {\n        id: string;\n        type: TrackType;\n        data?: string;\n    }\n\n    export interface AudioZone {\n        id: number;\n        name: string;\n        players: Api.Player[];\n    }\n\n    export interface UpdateAudioZone {\n        id: number;\n        name?: string;\n        players?: number[];\n    }\n\n    export interface AudioZonePlaybackTarget {\n        type: 'AUDIO_ZONE';\n        audioZoneId: number;\n    }\n\n    export interface ConnectionOutputPlaybackTarget {\n        type: 'CONNECTION_OUTPUT';\n        connectionId: string;\n        outputId: string;\n    }\n\n    export type PlaybackTarget =\n        | AudioZonePlaybackTarget\n        | ConnectionOutputPlaybackTarget;\n\n    export interface PlaybackSession {\n        sessionId: number;\n        playbackTarget: PlaybackTarget;\n        name: string;\n        active: boolean;\n        playing: boolean;\n        position?: number;\n        seek?: number;\n        volume?: number;\n        playlist: PlaybackSessionPlaylist;\n        quality?: PlaybackQuality;\n    }\n\n    export interface PlaybackSessionPlaylist {\n        sessionPlaylistId: number;\n        tracks: GenericTrack[];\n    }\n\n    export type ArtistSort = 'Name' | 'Name-Desc';\n\n    export type ArtistsRequest = {\n        sources?: AlbumSource[] | undefined;\n        sort?: ArtistSort | undefined;\n        filters?: ArtistFilters | undefined;\n    };\n\n    export type ArtistFilters = {\n        search?: string | undefined;\n    };\n\n    export type AlbumSource = 'Local' | 'Tidal' | 'Qobuz';\n    export type AlbumSort =\n        | 'Artist'\n        | 'Artist-Desc'\n        | 'Name'\n        | 'Name-Desc'\n        | 'Release-Date'\n        | 'Release-Date-Desc'\n        | 'Date-Added'\n        | 'Date-Added-Desc';\n\n    export type AlbumsRequest = {\n        artistId?: number | undefined;\n        tidalArtistId?: number | undefined;\n        qobuzArtistId?: number | undefined;\n        sources?: AlbumSource[] | undefined;\n        sort?: AlbumSort | undefined;\n        filters?: AlbumFilters | undefined;\n        offset?: number | undefined;\n        limit?: number | undefined;\n    };\n\n    export type AlbumFilters = {\n        search?: string | undefined;\n    };\n\n    export function getPath(path: string): string {\n        path = path[0] === '/' ? path.substring(1) : path;\n        const containsQuery = path.includes('?');\n        const params = [];\n        const con = getConnection();\n\n        const clientId = con.clientId;\n        if (con.clientId) {\n            params.push(`clientId=${encodeURIComponent(clientId)}`);\n        }\n        const signatureToken = Api.signatureToken();\n        if (signatureToken) {\n            params.push(`signature=${encodeURIComponent(signatureToken)}`);\n        }\n        if (con.staticToken) {\n            params.push(`authorization=${encodeURIComponent(con.staticToken)}`);\n        }\n\n        const query = `${containsQuery ? '&' : '?'}${params.join('&')}`;\n\n        return `${con.apiUrl}/${path}${query}`;\n    }\n\n    export type QobuzPagingResponse<T> = {\n        items: T[];\n        hasMore: boolean;\n    };\n\n    type BasePagingResponse<T> = {\n        items: T[];\n        count: number;\n        offset: number;\n        limit: number;\n    };\n\n    export type PagingResponseWithTotal<T> = BasePagingResponse<T> & {\n        total: number;\n        hasMore: boolean;\n    };\n\n    export type PagingResponseWithHasMore<T> = BasePagingResponse<T> & {\n        hasMore: boolean;\n    };\n\n    export type PagingResponse<T> =\n        | PagingResponseWithTotal<T>\n        | PagingResponseWithHasMore<T>;\n\n    export interface TidalArtist {\n        id: number;\n        title: string;\n        containsCover: boolean;\n        blur: boolean;\n        type: 'TIDAL';\n    }\n\n    export interface TidalAlbum {\n        id: number;\n        title: string;\n        artist: string;\n        artistId: number;\n        containsCover: boolean;\n        explicit: boolean;\n        copyright?: string | undefined;\n        dateReleased: string;\n        numberOfTracks: number;\n        audioQuality: 'LOSSLESS' | 'HIRES';\n        mediaMetadataTags: TidalMediaMetadataTag[];\n        blur: boolean;\n        type: 'TIDAL';\n    }\n\n    export type TidalAlbumType = 'LP' | 'EPS_AND_SINGLES' | 'COMPILATIONS';\n    export type TidalMediaMetadataTag =\n        | 'LOSSLESS'\n        | 'HIRES_LOSSLESS'\n        | 'MQA'\n        | 'DOLBY_ATMOS';\n\n    export interface TidalTrack {\n        id: number;\n        number: number;\n        title: string;\n        artist: string;\n        artistId: number;\n        containsCover: boolean;\n        explicit: boolean;\n        album: string;\n        albumId: number;\n        duration: number;\n        copyright: string;\n        numberOfTracks: number;\n        audioQuality: 'LOSSLESS' | 'HIRES';\n        mediaMetadataTags: TidalMediaMetadataTag[];\n        type: 'TIDAL';\n        source: ApiSource;\n    }\n\n    export interface QobuzArtist {\n        id: number;\n        title: string;\n        containsCover: boolean;\n        blur: boolean;\n        type: 'QOBUZ';\n    }\n\n    export interface QobuzAlbum {\n        id: string;\n        title: string;\n        artist: string;\n        artistId: number;\n        containsCover: boolean;\n        parentalWarning: boolean;\n        dateReleased: string;\n        numberOfTracks: number;\n        blur: boolean;\n        type: 'QOBUZ';\n    }\n\n    export type QobuzAlbumType = 'LP' | 'EPS_AND_SINGLES' | 'COMPILATIONS';\n\n    export interface QobuzTrack {\n        id: number;\n        number: number;\n        title: string;\n        artist: string;\n        artistId: number;\n        containsCover: boolean;\n        parentalWarning: boolean;\n        album: string;\n        albumId: number;\n        duration: number;\n        copyright: string;\n        numberOfTracks: number;\n        audioQuality: 'LOSSLESS' | 'HIRES';\n        mediaMetadataTags: ('LOSSLESS' | 'HIRES_LOSSLESS' | 'MQA')[];\n        type: 'QOBUZ';\n        source: ApiSource;\n    }\n\n    export interface YtArtist {\n        id: string;\n        title: string;\n        containsCover: boolean;\n        blur: boolean;\n        type: 'YT';\n    }\n\n    export interface YtAlbum {\n        id: string;\n        title: string;\n        artist: string;\n        artistId: string;\n        containsCover: boolean;\n        dateReleased: string;\n        numberOfTracks: number;\n        blur: boolean;\n        type: 'YT';\n    }\n\n    export interface YtTrack {\n        id: string;\n        number: number;\n        title: string;\n        artist: string;\n        artistId: string;\n        containsCover: boolean;\n        parentalWarning: boolean;\n        album: string;\n        albumId: number;\n        duration: number;\n        copyright: string;\n        numberOfTracks: number;\n        audioQuality: 'LOSSLESS' | 'HIRES';\n        mediaMetadataTags: ('LOSSLESS' | 'HIRES_LOSSLESS' | 'MQA')[];\n        type: 'YT';\n        source: ApiSource;\n    }\n\n    export type DownloadTaskState =\n        | 'PENDING'\n        | 'PAUSED'\n        | 'CANCELLED'\n        | 'STARTED'\n        | 'ERROR'\n        | 'FINISHED';\n\n    export type DownloadItemType = 'TRACK' | 'ALBUM_COVER' | 'ARTIST_COVER';\n    export type TrackDownloadItem = {\n        id: number;\n        type: 'TRACK';\n        artistId: number;\n        albumId: number;\n        trackId: number;\n        title: string;\n        source: DownloadApiSource;\n        quality: TrackAudioQuality;\n        containsCover: boolean;\n    };\n    export type AlbumCoverDownloadItem = {\n        type: 'ALBUM_COVER';\n        artistId: number;\n        artist: string;\n        albumId: number;\n        title: string;\n        source: DownloadApiSource;\n        containsCover: boolean;\n    };\n    export type ArtistCoverDownloadItem = {\n        type: 'ARTIST_COVER';\n        artistId: number;\n        albumId: number;\n        title: string;\n        source: DownloadApiSource;\n        containsCover: boolean;\n    };\n    export type DownloadItem =\n        | TrackDownloadItem\n        | AlbumCoverDownloadItem\n        | ArtistCoverDownloadItem;\n\n    export const TrackAudioQuality = {\n        Low: 'LOW', // MP3 320\n        FlacLossless: 'FLAC_LOSSLESS', // FLAC 16 bit 44.1kHz\n        FlacHiRes: 'FLAC_HI_RES', // FLAC 24 bit <= 96kHz\n        FlacHighestRes: 'FLAC_HIGHEST_RES', // FLAC 24 bit > 96kHz <= 192kHz\n    } as const;\n    export type TrackAudioQuality =\n        (typeof TrackAudioQuality)[keyof typeof TrackAudioQuality];\n\n    export type DownloadApiSource = 'TIDAL' | 'QOBUZ' | 'YT';\n\n    export interface DownloadTask {\n        id: number;\n        state: DownloadTaskState;\n        item: DownloadItem;\n        filePath: string;\n        progress: number;\n        bytes: number;\n        totalBytes: number;\n        speed?: number;\n    }\n}\n\nexport interface Connection {\n    id: number;\n    name: string;\n    apiUrl: string;\n    clientId: string;\n    token: string;\n    staticToken: string;\n    players?: Api.Player[];\n}\n\nexport function setActiveConnection(id: number) {\n    const cons = connections.get();\n    const existing = cons.find((x) => x.id === id);\n    if (!existing) throw new Error(`Invalid connection id: ${id}`);\n    setConnection(id, existing);\n}\n\nexport function setConnection(id: number, values: Partial<Connection>) {\n    const con = connection.get();\n    const updated: Connection = {\n        id,\n        name: values.name ?? con?.name ?? '',\n        apiUrl: values.apiUrl ?? con?.apiUrl ?? '',\n        clientId: values.clientId ?? con?.clientId ?? '',\n        token: values.token ?? con?.token ?? '',\n        staticToken: values.staticToken ?? con?.staticToken ?? '',\n    };\n    connection.set(updated);\n    const updatedConnections = connections.get();\n    const existingI = updatedConnections.findIndex((x) => x.id === updated.id);\n    if (existingI !== -1) {\n        updatedConnections[existingI] = updated;\n    } else {\n        updatedConnections.push(updated);\n    }\n    connections.set([...updatedConnections]);\n}\n\nexport const connections = clientAtom<Connection[]>([], 'api.v2.connections');\nconst $connections = () => connections.get();\n\nexport const connection = clientAtom<Connection | null>(\n    $connections()[0] ?? null,\n    'api.v2.connection',\n);\nconst $connection = () => connection.get();\n\nlet connectionId = 1;\n\n$connections()?.forEach((x) => {\n    if (x.id >= connectionId) {\n        connectionId = x.id + 1;\n    }\n});\n\nexport function getNewConnectionId(): number {\n    return connectionId++;\n}\n\nexport interface ApiType {\n    getArtist(\n        artistId: number,\n        signal?: AbortSignal | null,\n    ): Promise<Api.LibraryArtist>;\n    getArtistCover(\n        artist: Artist | Album | Track | undefined,\n        width: number,\n        height: number,\n    ): string;\n    getArtistSourceCover(artist: Artist | Album | Track | undefined): string;\n    getAlbum(\n        id: number,\n        signal?: AbortSignal | null,\n    ): Promise<Api.LibraryAlbum>;\n    getAlbums(\n        request: Api.AlbumsRequest | undefined,\n        signal?: AbortSignal | null,\n    ): Promise<Api.PagingResponseWithTotal<Api.LibraryAlbum>>;\n    getAllAlbums(\n        request: Api.AlbumsRequest | undefined,\n        onAlbums?: (\n            albums: Api.LibraryAlbum[],\n            allAlbums: Api.LibraryAlbum[],\n            index: number,\n        ) => void,\n        signal?: AbortSignal | null,\n    ): Promise<Api.LibraryAlbum[]>;\n    getAlbumArtwork(\n        album: Album | Track | undefined,\n        width: number,\n        height: number,\n        signal?: AbortSignal | null,\n    ): string;\n    getAlbumSourceArtwork(\n        album: Album | Track | undefined,\n        signal?: AbortSignal | null,\n    ): string;\n    getAlbumTracks(\n        albumId: number,\n        signal?: AbortSignal | null,\n    ): Promise<Api.LibraryTrack[]>;\n    getAlbumVersions(\n        albumId: number,\n        signal?: AbortSignal | null,\n    ): Promise<Api.AlbumVersion[]>;\n    getTracks(\n        trackIds: number[],\n        signal?: AbortSignal | null,\n    ): Promise<Api.LibraryTrack[]>;\n    getArtists(\n        request: Api.ArtistsRequest | undefined,\n        signal?: AbortSignal | null,\n    ): Promise<Api.LibraryArtist[]>;\n    fetchSignatureToken(\n        signal?: AbortSignal | null,\n    ): Promise<string | undefined>;\n    refetchSignatureToken(signal?: AbortSignal | null): Promise<void>;\n    validateSignatureToken(signal?: AbortSignal | null): Promise<void>;\n    validateSignatureTokenAndClient(\n        signature: string,\n        signal?: AbortSignal | null,\n    ): Promise<{ valid?: boolean; notFound?: boolean }>;\n    magicToken(\n        magicToken: string,\n        signal?: AbortSignal | null,\n    ): Promise<{ clientId: string; accessToken: string } | false>;\n    globalSearch(\n        query: string,\n        offset?: number,\n        limit?: number,\n        signal?: AbortSignal | null,\n    ): Promise<{ position: number; results: Api.GlobalSearchResult[] }>;\n    searchExternalMusicApi(\n        query: string,\n        api: string,\n        offset?: number,\n        limit?: number,\n        signal?: AbortSignal | null,\n    ): Promise<{ position: number; results: Api.GlobalSearchResult[] }>;\n    searchAll(\n        query: string,\n        offset?: number,\n        limit?: number,\n        onResults?: (\n            results: Api.GlobalSearchResult[],\n            allResults: Api.GlobalSearchResult[],\n            source: ApiSource,\n        ) => void,\n        signal?: AbortSignal | null,\n    ): Promise<Api.GlobalSearchResult[]>;\n    getArtistFromTidalArtistId(\n        tidalArtistId: number,\n        signal?: AbortSignal | null,\n    ): Promise<Api.LibraryArtist>;\n    getArtistFromQobuzArtistId(\n        qobuzArtistId: number,\n        signal?: AbortSignal | null,\n    ): Promise<Api.LibraryArtist>;\n    getArtistFromTidalAlbumId(\n        tidalAlbumId: number,\n        signal?: AbortSignal | null,\n    ): Promise<Api.LibraryArtist>;\n    getTidalArtist(\n        tidalArtistId: number,\n        signal?: AbortSignal | null,\n    ): Promise<Api.TidalArtist>;\n    getQobuzArtist(\n        qobuzArtistId: number,\n        signal?: AbortSignal | null,\n    ): Promise<Api.QobuzArtist>;\n    getAllTidalArtistAlbums(\n        tidalArtistId: number,\n        setter?: Setter<Api.TidalAlbum[] | undefined>,\n        types?: Api.TidalAlbumType[],\n        signal?: AbortSignal | null,\n    ): Promise<{\n        lps: Api.TidalAlbum[];\n        epsAndSingles: Api.TidalAlbum[];\n        compilations: Api.TidalAlbum[];\n    }>;\n    getAllQobuzArtistAlbums(\n        qobuzArtistId: number,\n        setter?: Setter<Api.QobuzAlbum[] | undefined>,\n        types?: Api.QobuzAlbumType[],\n        signal?: AbortSignal | null,\n    ): Promise<{\n        lps: Api.QobuzAlbum[];\n        epsAndSingles: Api.QobuzAlbum[];\n        compilations: Api.QobuzAlbum[];\n    }>;\n    getTidalArtistAlbums(\n        tidalArtistId: number,\n        albumType?: Api.TidalAlbumType,\n        signal?: AbortSignal | null,\n    ): Promise<Api.PagingResponse<Api.TidalAlbum>>;\n    getQobuzArtistAlbums(\n        qobuzArtistId: number,\n        albumType?: Api.QobuzAlbumType,\n        signal?: AbortSignal | null,\n    ): Promise<Api.QobuzPagingResponse<Api.QobuzAlbum>>;\n    getAlbumFromTidalAlbumId(\n        tidalAlbumId: number,\n        signal?: AbortSignal | null,\n    ): Promise<Api.LibraryAlbum>;\n    getAlbumFromQobuzAlbumId(\n        qobuzAlbumId: string,\n        signal?: AbortSignal | null,\n    ): Promise<Api.LibraryAlbum>;\n    getLibraryAlbumsFromTidalArtistId(\n        tidalArtistId: number,\n        signal?: AbortSignal | null,\n    ): Promise<Api.LibraryAlbum[]>;\n    getLibraryAlbumsFromQobuzArtistId(\n        qobuzArtistId: number,\n        signal?: AbortSignal | null,\n    ): Promise<Api.LibraryAlbum[]>;\n    getTidalAlbum(\n        tidalAlbumId: number,\n        signal?: AbortSignal | null,\n    ): Promise<Api.TidalAlbum>;\n    getQobuzAlbum(\n        qobuzAlbumId: string,\n        signal?: AbortSignal | null,\n    ): Promise<Api.QobuzAlbum>;\n    getTidalAlbumTracks(\n        tidalAlbumId: number,\n        signal?: AbortSignal | null,\n    ): Promise<Api.PagingResponse<Api.TidalTrack>>;\n    getQobuzAlbumTracks(\n        qobuzAlbumId: string,\n        signal?: AbortSignal | null,\n    ): Promise<Api.PagingResponse<Api.QobuzTrack>>;\n    getYtAlbumTracks(\n        ytAlbumId: string,\n        signal?: AbortSignal | null,\n    ): Promise<Api.PagingResponse<Api.YtTrack>>;\n    getTidalTrack(\n        tidalTrackId: number,\n        signal?: AbortSignal | null,\n    ): Promise<Api.TidalTrack>;\n    getTrackUrlForSource(\n        trackId: Id,\n        source: ApiSource,\n        audioQuality: Api.TrackAudioQuality,\n        signal?: AbortSignal | null,\n    ): Promise<string>;\n    addAlbumToLibrary(\n        albumId: {\n            tidalAlbumId?: number;\n            qobuzAlbumId?: string;\n        },\n        signal?: AbortSignal | null,\n    ): Promise<void>;\n    removeAlbumFromLibrary(\n        albumId: {\n            tidalAlbumId?: number;\n            qobuzAlbumId?: string;\n        },\n        signal?: AbortSignal | null,\n    ): Promise<Api.LibraryAlbum>;\n    refavoriteAlbum(\n        albumId: {\n            tidalAlbumId?: number;\n            qobuzAlbumId?: string;\n        },\n        signal?: AbortSignal | null,\n    ): Promise<Api.LibraryAlbum>;\n    retryDownload(taskId: number, signal?: AbortSignal | null): Promise<void>;\n    download(\n        items: {\n            trackId?: string | number;\n            trackIds?: (string | number)[];\n            albumId?: string | number;\n            albumIds?: (string | number)[];\n        },\n        source: Api.DownloadApiSource,\n        signal?: AbortSignal | null,\n    ): Promise<void>;\n    getDownloadTasks(\n        signal?: AbortSignal | null,\n    ): Promise<Api.PagingResponseWithTotal<Api.DownloadTask>>;\n    getTrackVisualization(\n        track: Track | number,\n        source: ApiSource,\n        max: number,\n        signal?: AbortSignal | null,\n    ): Promise<number[]>;\n    getAudioZones(\n        signal?: AbortSignal | null,\n    ): Promise<Api.PagingResponseWithTotal<Api.AudioZone>>;\n    createAudioZone(\n        name: string,\n        signal?: AbortSignal | null,\n    ): Promise<Api.AudioZone>;\n    updateAudioZone(\n        update: Api.UpdateAudioZone,\n        signal?: AbortSignal | null,\n    ): Promise<Api.AudioZone>;\n    deleteAudioZone(id: number, signal?: AbortSignal | null): Promise<void>;\n    runScan(origins: ScanOrigin[], signal?: AbortSignal | null): Promise<void>;\n    startScan(\n        origins: ScanOrigin[],\n        signal?: AbortSignal | null,\n    ): Promise<void>;\n    enableScanOrigin(\n        origin: ScanOrigin,\n        signal?: AbortSignal | null,\n    ): Promise<void>;\n    addScanPath(path: string, signal?: AbortSignal | null): Promise<void>;\n}\n\nexport function getConnection(): Connection {\n    return $connection() ?? throwExpression('No connection selected');\n}\n\nasync function getArtist(\n    artistId: number,\n    signal?: AbortSignal | null,\n): Promise<Api.LibraryArtist> {\n    const con = getConnection();\n\n    const query = new QueryParams({\n        artistId: `${artistId}`,\n    });\n\n    return await requestJson(`${con.apiUrl}/menu/artist?${query}`, {\n        credentials: 'include',\n        signal: signal ?? null,\n    });\n}\n\nfunction getAlbumArtwork(\n    album: Album | Track | undefined,\n    width: number,\n    height: number,\n): string {\n    if (!album) return '/img/album.svg';\n\n    const albumType = album.type;\n    const query = new QueryParams({\n        source: albumType,\n        artistId: album.artistId?.toString(),\n    });\n\n    switch (albumType) {\n        case 'LIBRARY':\n            if (album.containsCover) {\n                return Api.getPath(\n                    `files/albums/${album.albumId}/${width}x${height}?${query}`,\n                );\n            }\n            break;\n\n        case 'TIDAL':\n            if (album.containsCover) {\n                if ('albumId' in album) {\n                    return Api.getPath(\n                        `files/albums/${album.albumId}/${width}x${height}?${query}`,\n                    );\n                } else if ('id' in album) {\n                    return Api.getPath(\n                        `files/albums/${album.id}/${width}x${height}?${query}`,\n                    );\n                }\n            }\n            break;\n\n        case 'QOBUZ':\n            if (album.containsCover) {\n                if ('albumId' in album) {\n                    return Api.getPath(\n                        `files/albums/${album.albumId}/${width}x${height}?${query}`,\n                    );\n                } else if ('id' in album) {\n                    return Api.getPath(\n                        `files/albums/${album.id}/${width}x${height}?${query}`,\n                    );\n                }\n            }\n            break;\n\n        case 'YT':\n            if (album.containsCover) {\n                if ('albumId' in album) {\n                    return Api.getPath(\n                        `files/albums/${album.albumId}/${width}x${height}?${query}`,\n                    );\n                } else if ('id' in album) {\n                    return Api.getPath(\n                        `files/albums/${album.id}/${width}x${height}?${query}`,\n                    );\n                }\n            }\n            break;\n\n        default:\n            albumType satisfies never;\n    }\n\n    return '/img/album.svg';\n}\n\nfunction getAlbumSourceArtwork(album: Album | Track | undefined): string {\n    if (!album) return '/img/album.svg';\n\n    const albumType = album.type;\n    const query = new QueryParams({\n        source: albumType,\n        artistId: album.artistId.toString(),\n    });\n\n    switch (albumType) {\n        case 'LIBRARY':\n            if (album.containsCover) {\n                return Api.getPath(\n                    `files/albums/${album.albumId}/source?${query}`,\n                );\n            }\n            break;\n\n        case 'TIDAL':\n            if (album.containsCover) {\n                if ('albumId' in album) {\n                    return Api.getPath(\n                        `files/albums/${album.albumId}/source?${query}`,\n                    );\n                } else if ('id' in album) {\n                    return Api.getPath(\n                        `files/albums/${album.id}/source?${query}`,\n                    );\n                }\n            }\n            break;\n\n        case 'QOBUZ':\n            if (album.containsCover) {\n                if ('albumId' in album) {\n                    return Api.getPath(\n                        `files/albums/${album.albumId}/source?${query}`,\n                    );\n                } else if ('id' in album) {\n                    return Api.getPath(\n                        `files/albums/${album.id}/source?${query}`,\n                    );\n                }\n            }\n            break;\n\n        case 'YT':\n            if (album.containsCover) {\n                if ('albumId' in album) {\n                    return Api.getPath(\n                        `files/albums/${album.albumId}/source?${query}`,\n                    );\n                } else if ('id' in album) {\n                    return Api.getPath(\n                        `files/albums/${album.id}/source?${query}`,\n                    );\n                }\n            }\n            break;\n\n        default:\n            albumType satisfies never;\n    }\n\n    return '/img/album.svg';\n}\n\nasync function getAlbum(\n    id: number,\n    signal?: AbortSignal | null,\n): Promise<Api.LibraryAlbum> {\n    const con = getConnection();\n\n    const query = new QueryParams({\n        albumId: `${id}`,\n    });\n\n    return await requestJson(`${con.apiUrl}/menu/album?${query}`, {\n        credentials: 'include',\n        signal: signal ?? null,\n    });\n}\n\nasync function getAlbums(\n    albumsRequest: Api.AlbumsRequest | undefined = undefined,\n    signal?: AbortSignal | null,\n): Promise<Api.PagingResponseWithTotal<Api.LibraryAlbum>> {\n    const con = getConnection();\n    const query = new QueryParams({\n        artistId: albumsRequest?.artistId?.toString(),\n        tidalArtistId: albumsRequest?.tidalArtistId?.toString(),\n        qobuzArtistId: albumsRequest?.qobuzArtistId?.toString(),\n        offset: `${albumsRequest?.offset ?? 0}`,\n        limit: `${albumsRequest?.limit ?? 100}`,\n    });\n    if (albumsRequest?.sources)\n        query.set('sources', albumsRequest.sources.join(','));\n    if (albumsRequest?.sort) query.set('sort', albumsRequest.sort);\n    if (albumsRequest?.filters?.search)\n        query.set('search', albumsRequest.filters.search);\n\n    return await requestJson(`${con.apiUrl}/menu/albums?${query}`, {\n        credentials: 'include',\n        signal: signal ?? null,\n    });\n}\n\nasync function getAllAlbums(\n    albumsRequest: Api.AlbumsRequest | undefined = undefined,\n    onAlbums?: (\n        albums: Api.LibraryAlbum[],\n        allAlbums: Api.LibraryAlbum[],\n        index: number,\n    ) => void,\n    signal?: AbortSignal | null,\n): Promise<Api.LibraryAlbum[]> {\n    let offset = albumsRequest?.offset ?? 0;\n    let limit = albumsRequest?.limit ?? 100;\n\n    albumsRequest = albumsRequest ?? { offset, limit };\n\n    const page = await getAlbums(albumsRequest, signal);\n\n    let items = page.items;\n\n    onAlbums?.(page.items, items, 0);\n\n    if (signal?.aborted || !page.hasMore) return items;\n\n    offset = limit;\n    limit = Math.min(Math.max(100, Math.ceil((page.total - limit) / 6)), 1000);\n\n    const requests = [];\n\n    do {\n        requests.push({ ...albumsRequest, offset, limit });\n        offset += limit;\n    } while (offset < page.total);\n\n    const output = [items, ...requests.map(() => [])];\n\n    await Promise.all(\n        requests.map(async (request, i) => {\n            const page = await getAlbums(request, signal);\n\n            output[i + 1] = page.items;\n\n            items = output.flat();\n\n            onAlbums?.(page.items, items, i + 1);\n\n            return page;\n        }),\n    );\n\n    return items;\n}\n\nfunction getArtistCover(\n    artist: Artist | Album | Track | undefined,\n    width: number,\n    height: number,\n): string {\n    if (!artist) return '/img/album.svg';\n\n    const artistType = artist.type;\n    const query = new QueryParams({\n        source: artistType,\n    });\n\n    switch (artistType) {\n        case 'LIBRARY':\n            if (artist.containsCover) {\n                return Api.getPath(\n                    `files/artists/${artist.artistId}/${width}x${height}?${query}`,\n                );\n            }\n            break;\n\n        case 'TIDAL':\n            if (artist.containsCover) {\n                if ('artistId' in artist) {\n                    return Api.getPath(\n                        `files/artists/${artist.artistId}/${width}x${height}?${query}`,\n                    );\n                } else if ('id' in artist) {\n                    return Api.getPath(\n                        `files/artists/${artist.id}/${width}x${height}?${query}`,\n                    );\n                }\n            }\n            break;\n\n        case 'QOBUZ':\n            if (artist.containsCover) {\n                if ('artistId' in artist) {\n                    return Api.getPath(\n                        `files/artists/${artist.artistId}/${width}x${height}?${query}`,\n                    );\n                } else if ('id' in artist) {\n                    return Api.getPath(\n                        `files/artists/${artist.id}/${width}x${height}?${query}`,\n                    );\n                }\n            }\n            break;\n\n        case 'YT':\n            if (artist.containsCover) {\n                if ('artistId' in artist) {\n                    return Api.getPath(\n                        `files/artists/${artist.artistId}/${width}x${height}?${query}`,\n                    );\n                } else if ('id' in artist) {\n                    return Api.getPath(\n                        `files/artists/${artist.id}/${width}x${height}?${query}`,\n                    );\n                }\n            }\n            break;\n\n        default:\n            artistType satisfies never;\n    }\n\n    return '/img/album.svg';\n}\n\nfunction getArtistSourceCover(\n    artist: Artist | Album | Track | undefined,\n): string {\n    if (!artist) return '/img/album.svg';\n\n    const artistType = artist.type;\n    const query = new QueryParams({\n        source: artistType,\n    });\n\n    switch (artistType) {\n        case 'LIBRARY':\n            if (artist.containsCover) {\n                return Api.getPath(\n                    `files/artists/${artist.artistId}/source?${query}`,\n                );\n            }\n            break;\n\n        case 'TIDAL':\n            if (artist.containsCover) {\n                if ('artistId' in artist) {\n                    return Api.getPath(\n                        `files/artists/${artist.artistId}/source?${query}`,\n                    );\n                } else if ('id' in artist) {\n                    return Api.getPath(\n                        `files/artists/${artist.id}/source?${query}`,\n                    );\n                }\n            }\n            break;\n\n        case 'QOBUZ':\n            if (artist.containsCover) {\n                if ('artistId' in artist) {\n                    return Api.getPath(\n                        `files/artists/${artist.artistId}/source?${query}`,\n                    );\n                } else if ('id' in artist) {\n                    return Api.getPath(\n                        `files/artists/${artist.id}/source?${query}`,\n                    );\n                }\n            }\n            break;\n\n        case 'YT':\n            if (artist.containsCover) {\n                if ('artistId' in artist) {\n                    return Api.getPath(\n                        `files/artists/${artist.artistId}/source?${query}`,\n                    );\n                } else if ('id' in artist) {\n                    return Api.getPath(\n                        `files/artists/${artist.id}/source?${query}`,\n                    );\n                }\n            }\n            break;\n\n        default:\n            artistType satisfies never;\n    }\n\n    return '/img/album.svg';\n}\n\nasync function getAlbumTracks(\n    albumId: number,\n    signal?: AbortSignal | null,\n): Promise<Api.LibraryTrack[]> {\n    const con = getConnection();\n    return await requestJson(\n        `${con.apiUrl}/menu/album/tracks?albumId=${albumId}`,\n        {\n            method: 'GET',\n            credentials: 'include',\n            signal: signal ?? null,\n        },\n    );\n}\n\nasync function getAlbumVersions(\n    albumId: number,\n    signal?: AbortSignal | null,\n): Promise<Api.AlbumVersion[]> {\n    const con = getConnection();\n    return await requestJson(\n        `${con.apiUrl}/menu/album/versions?albumId=${albumId}`,\n        {\n            method: 'GET',\n            credentials: 'include',\n            signal: signal ?? null,\n        },\n    );\n}\n\nasync function getTracks(\n    trackIds: number[],\n    signal?: AbortSignal | null,\n): Promise<Api.LibraryTrack[]> {\n    const con = getConnection();\n    return await requestJson(\n        `${con.apiUrl}/menu/tracks?trackIds=${trackIds.join(',')}`,\n        {\n            method: 'GET',\n            credentials: 'include',\n            signal: signal ?? null,\n        },\n    );\n}\n\nasync function getArtists(\n    artistsRequest: Api.ArtistsRequest | undefined = undefined,\n    signal?: AbortSignal | null,\n): Promise<Api.LibraryArtist[]> {\n    const con = getConnection();\n    const query = new QueryParams();\n    if (artistsRequest?.sources)\n        query.set('sources', artistsRequest.sources.join(','));\n    if (artistsRequest?.sort) query.set('sort', artistsRequest.sort);\n    if (artistsRequest?.filters?.search)\n        query.set('search', artistsRequest.filters.search);\n\n    return await requestJson(`${con.apiUrl}/menu/artists?${query}`, {\n        credentials: 'include',\n        signal: signal ?? null,\n    });\n}\n\nasync function fetchSignatureToken(\n    signal?: AbortSignal | null,\n): Promise<string | undefined> {\n    const con = getConnection();\n    const { token } = await requestJson<{ token: string }>(\n        `${con.apiUrl}/auth/signature-token`,\n        {\n            credentials: 'include',\n            method: 'POST',\n            signal: signal ?? null,\n        },\n    );\n\n    return token;\n}\n\nconst [nonTunnelApis, setNonTunnelApis] = makePersisted(\n    createSignal<string[]>([]),\n    {\n        name: 'nonTunnelApis',\n    },\n);\n\nasync function validateSignatureTokenAndClient(\n    signature: string,\n    signal?: AbortSignal | null,\n): Promise<{ valid?: boolean; notFound?: boolean }> {\n    const con = getConnection();\n    const apis = nonTunnelApis();\n\n    if (apis.includes(con.apiUrl)) {\n        return { notFound: true };\n    }\n\n    try {\n        const { valid } = await requestJson<{ valid: boolean }>(\n            `${con.apiUrl}/auth/validate-signature-token?signature=${signature}`,\n            {\n                credentials: 'include',\n                method: 'POST',\n                signal: signal ?? null,\n            },\n        );\n\n        return { valid: !!valid };\n    } catch (e) {\n        if (e instanceof RequestError) {\n            if (e.response.status === 404) {\n                setNonTunnelApis([...apis, con.apiUrl]);\n                return { notFound: true };\n            }\n        }\n\n        return { valid: false };\n    }\n}\n\nasync function refetchSignatureToken(): Promise<void> {\n    console.debug('Refetching signature token');\n    const token = await api.fetchSignatureToken();\n\n    if (token) {\n        Api.setSignatureToken(token);\n    } else {\n        console.error('Failed to fetch signature token');\n    }\n}\n\nasync function validateSignatureToken(): Promise<void> {\n    const con = getConnection();\n    if (!con.token) return;\n\n    const existing = Api.signatureToken();\n\n    if (!existing) {\n        await api.refetchSignatureToken();\n\n        return;\n    }\n\n    const { valid, notFound } =\n        await api.validateSignatureTokenAndClient(existing);\n\n    if (notFound) {\n        console.debug('Not hitting tunnel server');\n        return;\n    }\n\n    if (!valid) {\n        await api.refetchSignatureToken();\n    }\n}\n\nasync function magicToken(\n    magicToken: string,\n    signal?: AbortSignal | null,\n): Promise<{ clientId: string; accessToken: string } | false> {\n    const con = getConnection();\n    try {\n        return await requestJson(\n            `${con.apiUrl}/auth/magic-token?magicToken=${magicToken}`,\n            {\n                credentials: 'include',\n                signal: signal ?? null,\n            },\n        );\n    } catch {\n        return false;\n    }\n}\n\nasync function globalSearch(\n    query: string,\n    offset?: number,\n    limit?: number,\n    signal?: AbortSignal | null,\n): Promise<{ position: number; results: Api.GlobalSearchResult[] }> {\n    const con = getConnection();\n    const queryParams = new QueryParams({\n        query,\n        offset: offset?.toString() ?? undefined,\n        limit: limit?.toString() ?? undefined,\n    });\n    return await requestJson(\n        `${con.apiUrl}/search/global-search?${queryParams.toString()}`,\n        {\n            credentials: 'include',\n            signal: signal ?? null,\n        },\n    );\n}\n\nasync function searchExternalMusicApi(\n    query: string,\n    api: string,\n    offset?: number,\n    limit?: number,\n    signal?: AbortSignal | null,\n): Promise<{ position: number; results: Api.GlobalSearchResult[] }> {\n    const con = getConnection();\n    const queryParams = new QueryParams({\n        query,\n        offset: offset?.toString() ?? undefined,\n        limit: limit?.toString() ?? undefined,\n    });\n    return await requestJson(\n        `${con.apiUrl}/${api}/search?${queryParams.toString()}`,\n        {\n            credentials: 'include',\n            signal: signal ?? null,\n        },\n    );\n}\n\nasync function searchAll(\n    query: string,\n    offset?: number,\n    limit?: number,\n    onResults?: (\n        results: Api.GlobalSearchResult[],\n        allResults: Api.GlobalSearchResult[],\n        source: ApiSource,\n    ) => void,\n    signal?: AbortSignal | null,\n): Promise<Api.GlobalSearchResult[]> {\n    const allResults: Api.GlobalSearchResult[] = [];\n    await Promise.all([\n        (async () => {\n            const results = (await globalSearch(query, offset, limit, signal))\n                .results;\n            allResults.push(...allResults);\n            onResults?.(results, allResults, 'LIBRARY');\n        })(),\n        (async () => {\n            const results = (\n                await searchExternalMusicApi(\n                    query,\n                    'tidal',\n                    offset,\n                    limit,\n                    signal,\n                )\n            ).results;\n            allResults.push(...allResults);\n            onResults?.(results, allResults, 'TIDAL');\n        })(),\n        (async () => {\n            const results = (\n                await searchExternalMusicApi(\n                    query,\n                    'qobuz',\n                    offset,\n                    limit,\n                    signal,\n                )\n            ).results;\n            allResults.push(...allResults);\n            onResults?.(results, allResults, 'QOBUZ');\n        })(),\n        (async () => {\n            const results = (\n                await searchExternalMusicApi(query, 'yt', offset, limit, signal)\n            ).results;\n            allResults.push(...allResults);\n            onResults?.(results, allResults, 'YT');\n        })(),\n    ]);\n\n    return allResults;\n}\n\nasync function getArtistFromTidalArtistId(\n    tidalArtistId: number,\n    signal?: AbortSignal | null,\n): Promise<Api.LibraryArtist> {\n    const con = getConnection();\n    const query = new QueryParams({\n        tidalArtistId: `${tidalArtistId}`,\n    });\n\n    return await requestJson(`${con.apiUrl}/menu/artist?${query}`, {\n        credentials: 'include',\n        signal: signal ?? null,\n    });\n}\n\nasync function getArtistFromQobuzArtistId(\n    qobuzArtistId: number,\n    signal?: AbortSignal | null,\n): Promise<Api.LibraryArtist> {\n    const con = getConnection();\n    const query = new QueryParams({\n        qobuzArtistId: `${qobuzArtistId}`,\n    });\n\n    return await requestJson(`${con.apiUrl}/menu/artist?${query}`, {\n        credentials: 'include',\n        signal: signal ?? null,\n    });\n}\n\nasync function getArtistFromTidalAlbumId(\n    tidalAlbumId: number,\n    signal?: AbortSignal | null,\n): Promise<Api.LibraryArtist> {\n    const con = getConnection();\n    const query = new QueryParams({\n        tidalAlbumId: `${tidalAlbumId}`,\n    });\n\n    return await requestJson(`${con.apiUrl}/menu/artist?${query}`, {\n        credentials: 'include',\n        signal: signal ?? null,\n    });\n}\n\nasync function getTidalArtist(\n    tidalArtistId: number,\n    signal?: AbortSignal | null,\n): Promise<Api.TidalArtist> {\n    const con = getConnection();\n    const query = new QueryParams({\n        artistId: `${tidalArtistId}`,\n    });\n\n    return await requestJson(`${con.apiUrl}/tidal/artists?${query}`, {\n        credentials: 'include',\n        signal: signal ?? null,\n    });\n}\n\nasync function getQobuzArtist(\n    qobuzArtistId: number,\n    signal?: AbortSignal | null,\n): Promise<Api.QobuzArtist> {\n    const con = getConnection();\n    const query = new QueryParams({\n        artistId: `${qobuzArtistId}`,\n    });\n\n    return await requestJson(`${con.apiUrl}/qobuz/artists?${query}`, {\n        credentials: 'include',\n        signal: signal ?? null,\n    });\n}\n\nexport function sortAlbumsByDateDesc<T extends Album>(albums: T[]): T[] {\n    return albums.toSorted((a, b) => {\n        if (!a.dateReleased) return 1;\n        if (!b.dateReleased) return -1;\n\n        return b.dateReleased.localeCompare(a.dateReleased);\n    });\n}\n\nasync function getAllTidalArtistAlbums(\n    tidalArtistId: number,\n    setter?: Setter<Api.TidalAlbum[] | undefined>,\n    types?: Api.TidalAlbumType[],\n    signal?: AbortSignal | null,\n): Promise<{\n    lps: Api.TidalAlbum[];\n    epsAndSingles: Api.TidalAlbum[];\n    compilations: Api.TidalAlbum[];\n}> {\n    const albums: Awaited<ReturnType<typeof getAllTidalArtistAlbums>> = {\n        lps: [],\n        epsAndSingles: [],\n        compilations: [],\n    };\n\n    const promises = [];\n\n    if (!types || types.find((t) => t === 'LP')) {\n        promises.push(\n            (async () => {\n                const page = await api.getTidalArtistAlbums(\n                    tidalArtistId,\n                    'LP',\n                    signal ?? null,\n                );\n\n                albums.lps = page.items;\n\n                if (setter) {\n                    const { lps, epsAndSingles, compilations } = albums;\n                    setter(\n                        sortAlbumsByDateDesc([\n                            ...lps,\n                            ...epsAndSingles,\n                            ...compilations,\n                        ]),\n                    );\n                }\n            })(),\n        );\n    }\n    if (!types || types.find((t) => t === 'EPS_AND_SINGLES')) {\n        promises.push(\n            (async () => {\n                const page = await api.getTidalArtistAlbums(\n                    tidalArtistId,\n                    'EPS_AND_SINGLES',\n                    signal ?? null,\n                );\n\n                if (setter) {\n                    albums.epsAndSingles = page.items;\n\n                    const { lps, epsAndSingles, compilations } = albums;\n                    setter(\n                        sortAlbumsByDateDesc([\n                            ...lps,\n                            ...epsAndSingles,\n                            ...compilations,\n                        ]),\n                    );\n                }\n            })(),\n        );\n    }\n    if (!types || types.find((t) => t === 'COMPILATIONS')) {\n        promises.push(\n            (async () => {\n                const page = await api.getTidalArtistAlbums(\n                    tidalArtistId,\n                    'COMPILATIONS',\n                    signal ?? null,\n                );\n\n                if (setter) {\n                    albums.compilations = page.items;\n\n                    const { lps, epsAndSingles, compilations } = albums;\n                    setter(\n                        sortAlbumsByDateDesc([\n                            ...lps,\n                            ...epsAndSingles,\n                            ...compilations,\n                        ]),\n                    );\n                }\n            })(),\n        );\n    }\n\n    await Promise.all(promises);\n\n    return albums;\n}\n\nasync function getAllQobuzArtistAlbums(\n    qobuzArtistId: number,\n    setter?: Setter<Api.QobuzAlbum[] | undefined>,\n    types?: Api.QobuzAlbumType[],\n    signal?: AbortSignal | null,\n): Promise<{\n    lps: Api.QobuzAlbum[];\n    epsAndSingles: Api.QobuzAlbum[];\n    compilations: Api.QobuzAlbum[];\n}> {\n    const albums: Awaited<ReturnType<typeof getAllQobuzArtistAlbums>> = {\n        lps: [],\n        epsAndSingles: [],\n        compilations: [],\n    };\n\n    const promises = [];\n\n    if (!types || types.find((t) => t === 'LP')) {\n        promises.push(\n            (async () => {\n                const page = await api.getQobuzArtistAlbums(\n                    qobuzArtistId,\n                    'LP',\n                    signal ?? null,\n                );\n\n                albums.lps = page.items;\n\n                if (setter) {\n                    const { lps, epsAndSingles, compilations } = albums;\n                    setter(\n                        sortAlbumsByDateDesc([\n                            ...lps,\n                            ...epsAndSingles,\n                            ...compilations,\n                        ]),\n                    );\n                }\n            })(),\n        );\n    }\n    if (!types || types.find((t) => t === 'EPS_AND_SINGLES')) {\n        promises.push(\n            (async () => {\n                const page = await api.getQobuzArtistAlbums(\n                    qobuzArtistId,\n                    'EPS_AND_SINGLES',\n                    signal ?? null,\n                );\n\n                if (setter) {\n                    albums.epsAndSingles = page.items;\n\n                    const { lps, epsAndSingles, compilations } = albums;\n                    setter(\n                        sortAlbumsByDateDesc([\n                            ...lps,\n                            ...epsAndSingles,\n                            ...compilations,\n                        ]),\n                    );\n                }\n            })(),\n        );\n    }\n    if (!types || types.find((t) => t === 'COMPILATIONS')) {\n        promises.push(\n            (async () => {\n                const page = await api.getQobuzArtistAlbums(\n                    qobuzArtistId,\n                    'COMPILATIONS',\n                    signal ?? null,\n                );\n\n                if (setter) {\n                    albums.compilations = page.items;\n\n                    const { lps, epsAndSingles, compilations } = albums;\n                    setter(\n                        sortAlbumsByDateDesc([\n                            ...lps,\n                            ...epsAndSingles,\n                            ...compilations,\n                        ]),\n                    );\n                }\n            })(),\n        );\n    }\n\n    await Promise.all(promises);\n\n    return albums;\n}\n\nasync function getTidalArtistAlbums(\n    tidalArtistId: number,\n    albumType?: Api.TidalAlbumType,\n    signal?: AbortSignal | null,\n): Promise<Api.PagingResponse<Api.TidalAlbum>> {\n    const con = getConnection();\n    const query = new QueryParams({\n        artistId: `${tidalArtistId}`,\n    });\n\n    if (albumType) {\n        query.set('albumType', albumType);\n    }\n\n    return await requestJson(`${con.apiUrl}/tidal/artists/albums?${query}`, {\n        credentials: 'include',\n        signal: signal ?? null,\n    });\n}\n\nasync function getQobuzArtistAlbums(\n    qobuzArtistId: number,\n    albumType?: Api.QobuzAlbumType,\n    signal?: AbortSignal | null,\n): Promise<Api.QobuzPagingResponse<Api.QobuzAlbum>> {\n    const con = getConnection();\n    const query = new QueryParams({\n        artistId: `${qobuzArtistId}`,\n    });\n\n    if (albumType) {\n        query.set('releaseType', albumType);\n    }\n\n    return await requestJson(`${con.apiUrl}/qobuz/artists/albums?${query}`, {\n        credentials: 'include',\n        signal: signal ?? null,\n    });\n}\n\nasync function getAlbumFromTidalAlbumId(\n    tidalAlbumId: number,\n    signal?: AbortSignal | null,\n): Promise<Api.LibraryAlbum> {\n    const con = getConnection();\n    const query = new QueryParams({\n        tidalAlbumId: `${tidalAlbumId}`,\n    });\n\n    return await requestJson(`${con.apiUrl}/menu/album?${query}`, {\n        credentials: 'include',\n        signal: signal ?? null,\n    });\n}\n\nasync function getAlbumFromQobuzAlbumId(\n    qobuzAlbumId: string,\n    signal?: AbortSignal | null,\n): Promise<Api.LibraryAlbum> {\n    const con = getConnection();\n    const query = new QueryParams({\n        qobuzAlbumId: `${qobuzAlbumId}`,\n    });\n\n    return await requestJson(`${con.apiUrl}/menu/album?${query}`, {\n        credentials: 'include',\n        signal: signal ?? null,\n    });\n}\n\nasync function getLibraryAlbumsFromTidalArtistId(\n    tidalArtistId: number,\n    signal?: AbortSignal | null,\n): Promise<Api.LibraryAlbum[]> {\n    const con = getConnection();\n    const query = new QueryParams({\n        tidalArtistId: `${tidalArtistId}`,\n    });\n\n    return await requestJson(`${con.apiUrl}/menu/albums?${query}`, {\n        credentials: 'include',\n        signal: signal ?? null,\n    });\n}\n\nasync function getLibraryAlbumsFromQobuzArtistId(\n    qobuzArtistId: number,\n    signal?: AbortSignal | null,\n): Promise<Api.LibraryAlbum[]> {\n    const con = getConnection();\n    const query = new QueryParams({\n        qobuzArtistId: `${qobuzArtistId}`,\n    });\n\n    return await requestJson(`${con.apiUrl}/menu/albums?${query}`, {\n        credentials: 'include',\n        signal: signal ?? null,\n    });\n}\n\nasync function getTidalAlbum(\n    tidalAlbumId: number,\n    signal?: AbortSignal | null,\n): Promise<Api.TidalAlbum> {\n    const con = getConnection();\n    const query = new QueryParams({\n        albumId: `${tidalAlbumId}`,\n    });\n\n    return await requestJson(`${con.apiUrl}/tidal/albums?${query}`, {\n        credentials: 'include',\n        signal: signal ?? null,\n    });\n}\n\nasync function getQobuzAlbum(\n    qobuzAlbumId: string,\n    signal?: AbortSignal | null,\n): Promise<Api.QobuzAlbum> {\n    const con = getConnection();\n    const query = new QueryParams({\n        albumId: `${qobuzAlbumId}`,\n    });\n\n    return await requestJson(`${con.apiUrl}/qobuz/albums?${query}`, {\n        credentials: 'include',\n        signal: signal ?? null,\n    });\n}\n\nasync function getTidalAlbumTracks(\n    tidalAlbumId: number,\n    signal?: AbortSignal | null,\n): Promise<Api.PagingResponse<Api.TidalTrack>> {\n    const con = getConnection();\n    const query = new QueryParams({\n        albumId: `${tidalAlbumId}`,\n    });\n\n    return await requestJson(`${con.apiUrl}/tidal/albums/tracks?${query}`, {\n        credentials: 'include',\n        signal: signal ?? null,\n    });\n}\n\nasync function getQobuzAlbumTracks(\n    qobuzAlbumId: string,\n    signal?: AbortSignal | null,\n): Promise<Api.PagingResponse<Api.QobuzTrack>> {\n    const con = getConnection();\n    const query = new QueryParams({\n        albumId: `${qobuzAlbumId}`,\n    });\n\n    return await requestJson(`${con.apiUrl}/qobuz/albums/tracks?${query}`, {\n        credentials: 'include',\n        signal: signal ?? null,\n    });\n}\n\nasync function getYtAlbumTracks(\n    ytAlbumId: string,\n    signal?: AbortSignal | null,\n): Promise<Api.PagingResponse<Api.YtTrack>> {\n    const con = getConnection();\n    const query = new QueryParams({\n        albumId: `${ytAlbumId}`,\n    });\n\n    return await requestJson(`${con.apiUrl}/yt/albums/tracks?${query}`, {\n        credentials: 'include',\n        signal: signal ?? null,\n    });\n}\n\nasync function getTidalTrack(\n    tidalTrackId: number,\n    signal?: AbortSignal | null,\n): Promise<Api.TidalTrack> {\n    const con = getConnection();\n    const query = new QueryParams({\n        trackId: `${tidalTrackId}`,\n    });\n\n    return await requestJson(`${con.apiUrl}/tidal/track?${query}`, {\n        credentials: 'include',\n        signal: signal ?? null,\n    });\n}\n\nasync function getTrackUrlForSource(\n    trackId: Id,\n    source: ApiSource,\n    audioQuality: Api.TrackAudioQuality,\n    signal?: AbortSignal | null,\n): Promise<string> {\n    const con = getConnection();\n    const query = new QueryParams({\n        audioQuality,\n        trackId: `${trackId}`,\n        source: `${source}`,\n    });\n\n    const urls = await requestJson<string[]>(\n        `${con.apiUrl}/files/tracks/url?${query}`,\n        {\n            credentials: 'include',\n            signal: signal ?? null,\n        },\n    );\n\n    return urls[0]!;\n}\n\nasync function addAlbumToLibrary(\n    albumId: {\n        tidalAlbumId?: number;\n        qobuzAlbumId?: string;\n    },\n    signal?: AbortSignal | null,\n): Promise<void> {\n    const con = getConnection();\n    const query = new QueryParams({\n        albumId: albumId.tidalAlbumId?.toString() ?? albumId.qobuzAlbumId,\n        source: albumId.tidalAlbumId\n            ? 'TIDAL'\n            : albumId.qobuzAlbumId\n              ? 'QOBUZ'\n              : undefined,\n    });\n\n    return await requestJson(`${con.apiUrl}/menu/album?${query}`, {\n        method: 'POST',\n        credentials: 'include',\n        signal: signal ?? null,\n    });\n}\n\nasync function removeAlbumFromLibrary(\n    albumId: {\n        tidalAlbumId?: number;\n        qobuzAlbumId?: string;\n    },\n    signal?: AbortSignal | null,\n): Promise<Api.LibraryAlbum> {\n    const con = getConnection();\n    const query = new QueryParams({\n        albumId: albumId.tidalAlbumId?.toString() ?? albumId.qobuzAlbumId,\n        source: albumId.tidalAlbumId\n            ? 'TIDAL'\n            : albumId.qobuzAlbumId\n              ? 'QOBUZ'\n              : undefined,\n    });\n\n    return await requestJson(`${con.apiUrl}/menu/album?${query}`, {\n        method: 'DELETE',\n        credentials: 'include',\n        signal: signal ?? null,\n    });\n}\n\nasync function refavoriteAlbum(\n    albumId: {\n        tidalAlbumId?: number;\n        qobuzAlbumId?: string;\n    },\n    signal?: AbortSignal | null,\n): Promise<Api.LibraryAlbum> {\n    const con = getConnection();\n    const query = new QueryParams({\n        albumId: albumId.tidalAlbumId?.toString() ?? albumId.qobuzAlbumId,\n        source: albumId.tidalAlbumId\n            ? 'TIDAL'\n            : albumId.qobuzAlbumId\n              ? 'QOBUZ'\n              : undefined,\n    });\n\n    return await requestJson(`${con.apiUrl}/menu/album/re-favorite?${query}`, {\n        method: 'POST',\n        credentials: 'include',\n        signal: signal ?? null,\n    });\n}\n\nasync function retryDownload(\n    taskId: number,\n    signal?: AbortSignal | null,\n): Promise<void> {\n    const con = getConnection();\n    const query = new QueryParams({\n        taskId: `${taskId}`,\n    });\n\n    return await requestJson(\n        `${con.apiUrl}/downloader/retry-download?${query}`,\n        {\n            method: 'POST',\n            credentials: 'include',\n            signal: signal ?? null,\n        },\n    );\n}\n\nasync function download(\n    items: {\n        trackId?: string | number;\n        trackIds?: (string | number)[];\n        albumId?: string | number;\n        albumIds?: (string | number)[];\n    },\n    source: Api.DownloadApiSource,\n    signal?: AbortSignal | null,\n): Promise<void> {\n    const con = getConnection();\n    const query = new QueryParams({\n        trackId: items.trackId ? `${items.trackId}` : undefined,\n        trackIds: items.trackIds ? `${items.trackIds.join(',')}` : undefined,\n        albumId: items.albumId ? `${items.albumId}` : undefined,\n        albumIds: items.albumIds ? `${items.albumIds.join(',')}` : undefined,\n        source: `${source}`,\n    });\n\n    return await requestJson(`${con.apiUrl}/downloader/download?${query}`, {\n        method: 'POST',\n        credentials: 'include',\n        signal: signal ?? null,\n    });\n}\n\nasync function getDownloadTasks(\n    signal?: AbortSignal | null,\n): Promise<Api.PagingResponseWithTotal<Api.DownloadTask>> {\n    const con = getConnection();\n    return await requestJson(`${con.apiUrl}/downloader/download-tasks`, {\n        credentials: 'include',\n        signal: signal ?? null,\n    });\n}\n\nasync function getTrackVisualization(\n    track: Track | number,\n    source: ApiSource,\n    max: number,\n    signal?: AbortSignal | null,\n): Promise<number[]> {\n    const con = getConnection();\n    const query = new QueryParams({\n        trackId: `${trackId(track)}`,\n        max: `${Math.ceil(max)}`,\n        source: `${source}`,\n    });\n\n    return await requestJson(\n        `${con.apiUrl}/files/track/visualization?${query}`,\n        {\n            credentials: 'include',\n            signal: signal ?? null,\n        },\n    );\n}\n\nasync function getAudioZones(\n    signal?: AbortSignal | null,\n): Promise<Api.PagingResponseWithTotal<Api.AudioZone>> {\n    const con = getConnection();\n    const query = new QueryParams({ offset: `0`, limit: `100` });\n\n    return await requestJson(`${con.apiUrl}/audio-zone?${query}`, {\n        credentials: 'include',\n        signal: signal ?? null,\n    });\n}\n\nasync function createAudioZone(\n    name: string,\n    signal?: AbortSignal | null,\n): Promise<Api.AudioZone> {\n    const con = getConnection();\n    const query = new QueryParams({ name });\n\n    return await requestJson(`${con.apiUrl}/audio-zone?${query}`, {\n        method: 'POST',\n        credentials: 'include',\n        signal: signal ?? null,\n    });\n}\n\nasync function updateAudioZone(\n    update: Api.UpdateAudioZone,\n    signal?: AbortSignal | null,\n): Promise<Api.AudioZone> {\n    const con = getConnection();\n\n    return await requestJson(`${con.apiUrl}/audio-zone`, {\n        method: 'PATCH',\n        body: JSON.stringify(update),\n        credentials: 'include',\n        signal: signal ?? null,\n    });\n}\n\nasync function deleteAudioZone(\n    id: number,\n    signal?: AbortSignal | null,\n): Promise<void> {\n    const con = getConnection();\n    const query = new QueryParams({ id: `${id}` });\n\n    return await requestJson(`${con.apiUrl}/audio-zone?${query}`, {\n        method: 'DELETE',\n        credentials: 'include',\n        signal: signal ?? null,\n    });\n}\n\nasync function runScan(\n    origins: ScanOrigin[],\n    signal?: AbortSignal | null,\n): Promise<void> {\n    const con = getConnection();\n    const query = new QueryParams({ origins: `${origins.join(',')}` });\n\n    return await requestJson(`${con.apiUrl}/scan/run-scan?${query}`, {\n        method: 'POST',\n        credentials: 'include',\n        signal: signal ?? null,\n    });\n}\n\nasync function startScan(\n    origins: ScanOrigin[],\n    signal?: AbortSignal | null,\n): Promise<void> {\n    const con = getConnection();\n    const query = new QueryParams({ origins: `${origins.join(',')}` });\n\n    return await requestJson(`${con.apiUrl}/scan/start-scan?${query}`, {\n        method: 'POST',\n        credentials: 'include',\n        signal: signal ?? null,\n    });\n}\n\nasync function enableScanOrigin(\n    origin: ScanOrigin,\n    signal?: AbortSignal | null,\n): Promise<void> {\n    const con = getConnection();\n    const query = new QueryParams({ origin: `${origin}` });\n\n    return await requestJson(`${con.apiUrl}/scan/scan-origins?${query}`, {\n        method: 'POST',\n        credentials: 'include',\n        signal: signal ?? null,\n    });\n}\n\nasync function addScanPath(\n    path: string,\n    signal?: AbortSignal | null,\n): Promise<void> {\n    const con = getConnection();\n    const query = new QueryParams({ path: `${path}` });\n\n    return await requestJson(`${con.apiUrl}/scan/scan-paths?${query}`, {\n        method: 'POST',\n        credentials: 'include',\n        signal: signal ?? null,\n    });\n}\n\nclass RequestError extends Error {\n    constructor(public response: Response) {\n        let message = `Request failed: ${response.status}`;\n\n        if (response.statusText) {\n            message += ` (${response.statusText})`;\n        }\n\n        if (response.url) {\n            message += ` (url='${response.url}')`;\n        }\n\n        if (typeof response.redirected !== 'undefined') {\n            message += ` (redirected=${response.redirected})`;\n        }\n\n        if (response.headers) {\n            message += ` (headers=${objToStr(response.headers)})`;\n        }\n\n        if (response.type) {\n            message += ` (type=${response.type})`;\n        }\n\n        super(message);\n    }\n}\n\nasync function requestJson<T>(\n    url: string,\n    options: Parameters<typeof fetch>[1],\n): Promise<T> {\n    const con = getConnection();\n\n    if (url[url.length - 1] === '?') url = url.substring(0, url.length - 1);\n\n    const params = new QueryParams();\n    const clientId = con.clientId;\n\n    if (clientId) {\n        params.set('clientId', clientId);\n    }\n\n    if (params.size > 0) {\n        if (url.indexOf('?') > 0) {\n            url += `&${params}`;\n        } else {\n            url += `?${params}`;\n        }\n    }\n\n    const token = con.staticToken || con.token;\n    const headers = {\n        'Content-Type': 'application/json',\n        ...(options?.headers ?? {}),\n    } as { [key: string]: string };\n\n    if (token && !headers.Authorization) {\n        headers.Authorization = token;\n    }\n\n    options = {\n        ...options,\n        headers,\n    };\n\n    const response = await fetch(url, options);\n\n    if (!response.ok) {\n        throw new RequestError(response);\n    }\n\n    return await response.json();\n}\n\nexport function cancellable<T>(func: (signal: AbortSignal) => Promise<T>): {\n    data: Promise<T>;\n    controller: AbortController;\n    signal: AbortSignal;\n} {\n    const controller = new AbortController();\n    const signal = controller.signal;\n\n    return { data: func(signal), controller, signal };\n}\n\nconst abortControllers: { [id: string]: AbortController } = {};\n\nexport async function once<T>(\n    id: string,\n    func: (signal: AbortSignal) => Promise<T>,\n): Promise<T> {\n    const controller = abortControllers[id];\n\n    if (controller) {\n        controller.abort();\n    }\n\n    const resp = cancellable(func);\n    abortControllers[id] = resp.controller;\n\n    let data: T;\n\n    try {\n        data = await resp.data;\n    } catch (e) {\n        throw e;\n    } finally {\n        delete abortControllers[id];\n    }\n\n    return data;\n}\n\nexport const api: ApiType = {\n    getArtist,\n    getArtistCover,\n    getArtistSourceCover,\n    getAlbum,\n    getAlbums,\n    getAllAlbums,\n    getAlbumArtwork,\n    getAlbumSourceArtwork,\n    getAlbumTracks,\n    getAlbumVersions,\n    getTracks,\n    getArtists,\n    fetchSignatureToken,\n    refetchSignatureToken,\n    validateSignatureTokenAndClient,\n    validateSignatureToken,\n    magicToken,\n    globalSearch,\n    searchExternalMusicApi,\n    searchAll,\n    getArtistFromTidalArtistId,\n    getArtistFromQobuzArtistId,\n    getArtistFromTidalAlbumId,\n    getAlbumFromTidalAlbumId,\n    getAlbumFromQobuzAlbumId,\n    getTidalArtist,\n    getQobuzArtist,\n    getAllTidalArtistAlbums,\n    getAllQobuzArtistAlbums,\n    getTidalArtistAlbums,\n    getQobuzArtistAlbums,\n    getLibraryAlbumsFromTidalArtistId,\n    getLibraryAlbumsFromQobuzArtistId,\n    getTidalAlbum,\n    getQobuzAlbum,\n    getTidalAlbumTracks,\n    getQobuzAlbumTracks,\n    getYtAlbumTracks,\n    getTidalTrack,\n    getTrackUrlForSource,\n    addAlbumToLibrary,\n    removeAlbumFromLibrary,\n    refavoriteAlbum,\n    getDownloadTasks,\n    getTrackVisualization,\n    retryDownload,\n    download,\n    getAudioZones,\n    createAudioZone,\n    updateAudioZone,\n    deleteAudioZone,\n    runScan,\n    startScan,\n    enableScanOrigin,\n    addScanPath,\n};\n"],"names":["listenerQueue","atom","initialValue","level","listeners","$atom","listener","listenerLevel","index","changedKey","runListenerQueue","i","skip","j","data","unbind","MOUNT","UNMOUNT","REVERT_MUTATION","on","object","eventKey","mutateStore","eventProps","event","l","currentListeners","STORE_UNMOUNT_DELAY","onMount","$store","initialize","payload","destroy","runListeners","originListen","args","originOff","identity","a","storageEngine","eventsEngine","testSupport","windowPersistentEvents","key","restore","persistentAtom","name","initial","opts","encode","decode","store","set","newValue","e","ClientAtom","value","mapping","v","x","clientAtom","clientSignal","init","get","createSignal","b","onCleanup","wasInit","createListener","callback","onFirst","off","c","orderedEntries","order","updates","key1","key2","first","second","QueryParams","pair","k","_value","existing","func","getQueryParam","setQueryParam","url","historyBack","isMobile","isUserAgentMobile","userAgent","areEqualShallow","circularStringify","obj","seen","_key","objToStr","throwExpression","errorMessage","deepEqual","y","prop","$RAW","$NODE","$HAS","$SELF","wrap$1","p","$PROXY","proxyTraps$1","keys","desc","isWrappable","proto","unwrap","item","result","unwrapped","getNodes","target","symbol","nodes","getNode","property","s","proxyDescriptor$1","trackSelf","getListener","ownKeys","receiver","$TRACK","tracked","setProperty","state","deleting","prev","len","node","mergeStoreNode","updateArray","current","next","updatePath","path","traversed","part","partType","isArray","from","to","by","createStore","options","unwrappedStore","wrappedStore","setStore","batch","$ROOT","applyState","parent","merge","previous","start","end","newEnd","newIndicesNext","keyVal","temp","newIndices","targetKeys","previousKeys","reconcile","res","producers","setterTraps","proxy","produce","fn","__require","addClearMethod","storage","cookiePropertyKeys","serializeCookieOptions","memo","deserializeCookieOptions","cookie","useRequest","cookieStorage","storageEvent","count","_","found","length","makePersisted","signal","storageOptions","createUniqueId","serialize","deserialize","unchanged","output","untrack","trackId","track","toSessionPlaylistTrack","Api","onSignatureTokenUpdatedListeners","_signatureToken","_setSignatureToken","signatureToken","setSignatureToken","PlayerType","TrackSource","getPath","containsQuery","params","con","getConnection","clientId","query","setActiveConnection","id","connections","setConnection","values","connection","updated","updatedConnections","existingI","$connections","$connection","connectionId","getNewConnectionId","getArtist","artistId","requestJson","getAlbumArtwork","album","width","height","albumType","getAlbumSourceArtwork","getAlbum","getAlbums","albumsRequest","getAllAlbums","onAlbums","offset","limit","page","items","requests","request","getArtistCover","artist","artistType","getArtistSourceCover","getAlbumTracks","albumId","getAlbumVersions","getTracks","trackIds","getArtists","artistsRequest","fetchSignatureToken","token","nonTunnelApis","setNonTunnelApis","validateSignatureTokenAndClient","signature","apis","valid","RequestError","refetchSignatureToken","api","validateSignatureToken","notFound","magicToken","globalSearch","queryParams","searchExternalMusicApi","searchAll","onResults","allResults","results","getArtistFromTidalArtistId","tidalArtistId","getArtistFromQobuzArtistId","qobuzArtistId","getArtistFromTidalAlbumId","tidalAlbumId","getTidalArtist","getQobuzArtist","sortAlbumsByDateDesc","albums","getAllTidalArtistAlbums","setter","types","promises","t","lps","epsAndSingles","compilations","getAllQobuzArtistAlbums","getTidalArtistAlbums","getQobuzArtistAlbums","getAlbumFromTidalAlbumId","getAlbumFromQobuzAlbumId","qobuzAlbumId","getLibraryAlbumsFromTidalArtistId","getLibraryAlbumsFromQobuzArtistId","getTidalAlbum","getQobuzAlbum","getTidalAlbumTracks","getQobuzAlbumTracks","getYtAlbumTracks","ytAlbumId","getTidalTrack","tidalTrackId","getTrackUrlForSource","source","audioQuality","addAlbumToLibrary","removeAlbumFromLibrary","refavoriteAlbum","retryDownload","taskId","download","getDownloadTasks","getTrackVisualization","max","getAudioZones","createAudioZone","updateAudioZone","update","deleteAudioZone","runScan","origins","startScan","enableScanOrigin","origin","addScanPath","response","message","headers","cancellable","controller","abortControllers","once","resp"],"mappings":"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","x_google_ignoreList":[0,1,2,4,5]}