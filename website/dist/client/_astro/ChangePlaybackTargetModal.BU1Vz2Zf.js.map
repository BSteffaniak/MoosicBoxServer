{"version":3,"file":"ChangePlaybackTargetModal.BU1Vz2Zf.js","sources":["../../../src/services/app.ts","../../../src/components/Modal/Modal.tsx","../../../src/components/ChangePlaybackTargetModal/ChangePlaybackTargetModal.tsx","../../../src/services/silence-player.ts","../../../src/services/player.ts","../../../src/services/downloads.ts","../../../src/services/scan.ts","../../../src/services/ws.ts"],"sourcesContent":["import { isServer } from 'solid-js/web';\nimport { Api, api, connection } from './api';\nimport { createSignal } from 'solid-js';\nimport { createStore, produce } from 'solid-js/store';\nimport { clientAtom } from './util';\nimport {\n    currentPlaybackTarget,\n    setCurrentPlaybackTarget,\n    setPlayerState,\n} from './player';\n\nexport const navigationBarExpanded = clientAtom<boolean>(\n    true,\n    'navigationBarExpanded',\n);\nexport const showAudioZones = clientAtom(false);\nexport const showPlaybackSessions = clientAtom(false);\nexport const showPlaybackQuality = clientAtom(false);\nexport const showChangePlaybackTargetModal = clientAtom(false);\nexport const showScanStatusBanner = clientAtom(false);\n\ntype StartupCallback = () => void | Promise<void>;\n\ndeclare global {\n    interface Window {\n        startupCallbacks: StartupCallback[];\n        startedUp: boolean;\n    }\n\n    var startupCallbacks: StartupCallback[];\n    // eslint-disable-next-line no-var\n    var startedUp: boolean;\n}\n\nif (isServer) global.startupCallbacks = global.startupCallbacks ?? [];\nelse window.startupCallbacks = window.startupCallbacks ?? [];\n\nfunction getStartupCallbacks(): StartupCallback[] {\n    if (isServer) {\n        const x = globalThis.startupCallbacks;\n        if (!x) globalThis.startupCallbacks = [];\n        return globalThis.startupCallbacks;\n    } else {\n        const x = window.startupCallbacks;\n        if (!x) window.startupCallbacks = [];\n        return window.startupCallbacks;\n    }\n}\n\nif (isServer) global.startedUp = global.startedUp ?? false;\nelse window.startedUp = window.startedUp ?? false;\n\nfunction isStartedUp(): boolean {\n    return (isServer ? globalThis.startedUp : window.startedUp) === true;\n}\n\nfunction setStartedUp(value: boolean) {\n    if (isServer) {\n        globalThis.startedUp = value;\n    } else {\n        window.startedUp = value;\n    }\n}\n\nexport function onStartupFirst(func: StartupCallback) {\n    if (isStartedUp()) {\n        func();\n        return;\n    }\n    getStartupCallbacks().unshift(func);\n}\n\nexport async function onStartup(func: StartupCallback) {\n    if (isStartedUp()) {\n        try {\n            await func();\n        } catch (e) {\n            console.error('Startup error:', e);\n        }\n        return;\n    }\n    getStartupCallbacks().push(func);\n}\n\nexport async function triggerStartup() {\n    if (isStartedUp()) return;\n    setStartedUp(true);\n\n    for (const func of getStartupCallbacks()) {\n        try {\n            await func();\n        } catch (e) {\n            console.error('Startup error:', e);\n        }\n    }\n}\n\ninterface AppState {\n    connections: Api.Connection[];\n    connection: Api.Connection | undefined;\n}\n\nexport const [appState, setAppState] = createStore<AppState>({\n    connections: [],\n    connection: undefined,\n});\n\nexport const [currentArtistSearch, setCurrentArtistSearch] = createSignal<{\n    query: string;\n    results: Api.LibraryArtist[];\n}>();\n\nexport const [currentAlbumSearch, setCurrentAlbumSearch] = createSignal<{\n    query: string;\n    results: Api.LibraryAlbum[];\n}>();\n\nconnection.listen((con, prev) => {\n    if (!con) return;\n    if (con.token !== prev?.token || con.clientId !== prev?.clientId) {\n        api.refetchSignatureToken();\n    }\n});\nonStartup(async () => {\n    const con = connection.get();\n\n    if (con && con.token && con.clientId) {\n        try {\n            await api.validateSignatureToken();\n        } catch (e) {\n            console.debug('Failed to validateSignatureToken:', e);\n        }\n    }\n});\nonStartup(async () => {\n    const zones = await api.getAudioZones();\n\n    setPlayerState(\n        produce((state) => {\n            state.audioZones = zones.items;\n\n            const current = currentPlaybackTarget();\n\n            if (current?.type === 'AUDIO_ZONE') {\n                const existing = state.audioZones.find(\n                    (x) => x.id === current.audioZoneId,\n                );\n\n                if (existing) {\n                    state.currentAudioZone = existing;\n                }\n            }\n\n            if (!state.currentAudioZone && !currentPlaybackTarget()) {\n                state.currentAudioZone = state.audioZones[0];\n                if (state.currentAudioZone) {\n                    setCurrentPlaybackTarget({\n                        type: 'AUDIO_ZONE',\n                        audioZoneId: state.currentAudioZone.id,\n                    });\n                }\n            }\n        }),\n    );\n});\n","import './modal.css';\nimport { type JSXElement, Show } from 'solid-js';\n\nexport interface ModalProps<T> {\n    class?: string | undefined;\n    show: () => T;\n    onClose: () => void | boolean;\n    children: JSXElement | ((value: NonNullable<T>) => JSXElement);\n}\n\nexport default function modalFunc<T>(props: ModalProps<T>) {\n    return (\n        <Show when={props.show()}>\n            {(value) => (\n                <div class=\"moosicbox-modal-container\" onClick={props.onClose}>\n                    <div\n                        class={`moosicbox-modal${props.class ? ` ${props.class}` : ''}`}\n                        onClick={(e) => e.stopPropagation()}\n                    >\n                        {typeof props.children === 'function'\n                            ? props.children(value())\n                            : props.children}\n                    </div>\n                </div>\n            )}\n        </Show>\n    );\n}\n","import './change-playback-target-modal.css';\nimport Modal from '../Modal';\nimport { showChangePlaybackTargetModal } from '~/services/app';\nimport { clientSignal } from '~/services/util';\n\nlet responsePromiseResolves: ((yes: boolean) => void)[] = [];\n\nexport async function responsePromise(): Promise<boolean> {\n    return new Promise((resolve) => {\n        responsePromiseResolves.push(resolve);\n    });\n}\n\nexport default function changePlaybackTargetModalFunc() {\n    const [$showChangePlaybackTargetModal] = clientSignal(\n        showChangePlaybackTargetModal,\n    );\n\n    return (\n        <div data-turbo-permanent id=\"change-playback-target-modal\">\n            <Modal\n                show={() => $showChangePlaybackTargetModal()}\n                onClose={() => showChangePlaybackTargetModal.set(false)}\n            >\n                <div class=\"change-playback-target-modal-container\">\n                    <div class=\"change-playback-target-modal-header\">\n                        <h1>Confirm</h1>\n                        <div\n                            class=\"change-playback-target-modal-close\"\n                            onClick={(e) => {\n                                showChangePlaybackTargetModal.set(false);\n                                e.stopImmediatePropagation();\n                            }}\n                        >\n                            <img\n                                class=\"cross-icon\"\n                                src=\"/img/cross-white.svg\"\n                                alt=\"Close change playback target modal\"\n                            />\n                        </div>\n                    </div>\n                    <div class=\"change-playback-target-modal-content\">\n                        Change playback target?\n                        <button\n                            class=\"remove-button-styles change-playback-target-modal-confirmation-button\"\n                            type=\"button\"\n                            onClick={(e) => {\n                                responsePromiseResolves.forEach((x) => x(true));\n                                responsePromiseResolves = [];\n                                showChangePlaybackTargetModal.set(false);\n                                e.stopImmediatePropagation();\n                            }}\n                        >\n                            yes\n                        </button>\n                        <button\n                            class=\"remove-button-styles change-playback-target-modal-confirmation-button\"\n                            type=\"button\"\n                            onClick={(e) => {\n                                responsePromiseResolves.forEach((x) =>\n                                    x(false),\n                                );\n                                responsePromiseResolves = [];\n                                showChangePlaybackTargetModal.set(false);\n                                e.stopImmediatePropagation();\n                            }}\n                        >\n                            no\n                        </button>\n                    </div>\n                </div>\n            </Modal>\n        </div>\n    );\n}\n","import { QueryParams } from './util';\nimport { Api, getConnection } from './api';\n\nlet tryingToPlay = false;\nlet audio: HTMLAudioElement | undefined;\n\nfunction initSilence() {\n    console.debug('initSilence');\n    const query = new QueryParams({\n        duration: `${5}`,\n        format: Api.AudioFormat.MP3,\n    });\n\n    const con = getConnection();\n    const clientIdParam = con.clientId;\n    const signatureToken = Api.signatureToken();\n\n    if (con.clientId && signatureToken) {\n        query.set('clientId', clientIdParam);\n        query.set('signature', signatureToken);\n    }\n    if (con.staticToken) {\n        query.set('authorization', con.staticToken);\n    }\n\n    const url = `${con.apiUrl}/files/silence?${query}`;\n\n    audio = new Audio(url);\n\n    // audio.addEventListener('timeupdate', (e) => {\n    //     console.log(e.timeStamp, audio.currentTime);\n    // });\n\n    audio.loop = true;\n    audio.play();\n    audio.addEventListener('error', (e) => {\n        console.error('Failed to start audio:', e.error);\n        tryingToPlay = false;\n        audio = undefined;\n    });\n}\n\nexport function isSilencePlaying(): boolean {\n    return tryingToPlay || audio?.paused === false;\n}\n\nexport function startSilence() {\n    console.debug('startSilence');\n    if (isSilencePlaying()) {\n        console.debug('startSilence: already playing');\n        return;\n    }\n    tryingToPlay = true;\n    initSilence();\n}\n\nexport function stopSilence() {\n    console.debug('stopSilence');\n    tryingToPlay = false;\n    if (!isSilencePlaying()) {\n        console.debug('stopSilence: already not playing');\n        return;\n    }\n}\n","import { createSignal } from 'solid-js';\nimport { Howl } from 'howler';\nimport { makePersisted } from '@solid-primitives/storage';\nimport { isServer } from 'solid-js/web';\nimport {\n    type Album,\n    Api,\n    type Track,\n    api,\n    toSessionPlaylistTrack,\n} from './api';\nimport { createStore, produce } from 'solid-js/store';\nimport { createListener, deepEqual, orderedEntries } from './util';\nimport { type PartialBy, type PartialUpdateSession } from './types';\nimport { wsService } from './ws';\nimport { appState, showChangePlaybackTargetModal } from './app';\nimport { responsePromise } from '~/components/ChangePlaybackTargetModal/ChangePlaybackTargetModal';\nimport { isSilencePlaying, startSilence, stopSilence } from './silence-player';\n\nexport type TrackListenerCallback = (\n    track: Api.LibraryTrack,\n    position: number,\n) => void;\n\ninterface PlayerState {\n    playing: boolean;\n    currentPlaybackSession?: Api.PlaybackSession | undefined;\n    playbackSessions: Api.PlaybackSession[];\n    currentAudioZone?: Api.AudioZone | undefined;\n    audioZones: Api.AudioZone[];\n    currentTrack?: Track | undefined;\n}\n\nexport const [playerState, setPlayerState] = createStore<PlayerState>({\n    playing: false,\n    currentPlaybackSession: undefined,\n    playbackSessions: [],\n    currentAudioZone: undefined,\n    audioZones: [],\n    currentTrack: undefined,\n});\n\nexport const [_playbackQuality, _setPlaybackQuality] = makePersisted(\n    createSignal<Api.PlaybackQuality>(\n        { format: Api.AudioFormat.SOURCE },\n        { equals: false },\n    ),\n    {\n        name: `player.v1.playbackQuality`,\n    },\n);\nconst onPlaybackQualityChangedListener =\n    createListener<\n        (\n            value: ReturnType<typeof _playbackQuality>,\n            old: ReturnType<typeof _playbackQuality>,\n        ) => boolean | void | Promise<boolean | void>\n    >();\nexport const onPlaybackQualityChanged = onPlaybackQualityChangedListener.on;\nexport const offPlaybackQualityChanged = onPlaybackQualityChangedListener.off;\nexport const playbackQuality = _playbackQuality;\nexport const setPlaybackQuality = (\n    value: Parameters<typeof _setPlaybackQuality>[0],\n    trigger = true,\n) => {\n    const old = _playbackQuality();\n    if (typeof value === 'function') {\n        value = value(old);\n    }\n    _setPlaybackQuality(value);\n    if (trigger && value !== old) {\n        onPlaybackQualityChangedListener.trigger(value, old);\n    }\n    updatePlayback({ quality: value });\n};\n\nexport const [_currentPlaybackTarget, _setCurrentPlaybackTarget] =\n    makePersisted(\n        createSignal<Api.PlaybackTarget | undefined>(undefined, {\n            equals: false,\n        }),\n        {\n            name: `player.v1.currentPlaybackTarget`,\n        },\n    );\nconst onCurrentPlaybackTargetChangedListener =\n    createListener<\n        (\n            value: ReturnType<typeof _currentPlaybackTarget>,\n            old: ReturnType<typeof _currentPlaybackTarget>,\n        ) => boolean | void | Promise<boolean | void>\n    >();\nexport const onCurrentPlaybackTargetChanged =\n    onCurrentPlaybackTargetChangedListener.on;\nexport const offCurrentPlaybackTargetChanged =\n    onCurrentPlaybackTargetChangedListener.off;\nexport const currentPlaybackTarget = _currentPlaybackTarget;\nexport const setCurrentPlaybackTarget = (\n    value: Parameters<typeof _setCurrentPlaybackTarget>[0],\n    trigger = true,\n) => {\n    const old = _currentPlaybackTarget();\n    if (typeof value === 'function') {\n        value = value(old);\n    }\n    _setCurrentPlaybackTarget(value);\n    if (trigger && value !== old) {\n        onCurrentPlaybackTargetChangedListener.trigger(value, old);\n    }\n    updatePlayback({});\n};\n\nexport const [currentPlaybackSessionId, setCurrentPlaybackSessionId] =\n    makePersisted(\n        createSignal<number | undefined>(undefined, { equals: false }),\n        {\n            name: `player.v1.currentPlaybackSessionId`,\n        },\n    );\n\nexport const [sound, setSound] = createSignal<Howl>();\n\nconst onVolumeChangedListener =\n    createListener<(value: number, old: number) => boolean | void>();\nexport const onVolumeChanged = onVolumeChangedListener.on;\nexport const offVolumeChanged = onVolumeChangedListener.off;\n\nexport function setVolume(volume: number) {\n    console.debug('Setting volume to', volume);\n    updatePlayback({ volume });\n}\n\nexport const [_currentSeek, _setCurrentSeek] = makePersisted(\n    createSignal<number | undefined>(undefined, { equals: false }),\n    {\n        name: `player.v1.currentSeek`,\n    },\n);\nconst onCurrentSeekChangedListener =\n    createListener<\n        (\n            value: ReturnType<typeof _currentSeek>,\n            old: ReturnType<typeof _currentSeek>,\n        ) => boolean | void\n    >();\nexport const onCurrentSeekChanged = onCurrentSeekChangedListener.on;\nexport const offCurrentSeekChanged = onCurrentSeekChangedListener.off;\nexport const currentSeek = _currentSeek;\nexport const setCurrentSeek = (\n    value: Parameters<typeof _setCurrentSeek>[0],\n    trigger = true,\n) => {\n    const old = _currentSeek();\n    if (typeof value === 'function') {\n        value = value(old);\n    }\n    _setCurrentSeek(value);\n    if (trigger && value !== old) {\n        onCurrentSeekChangedListener.trigger(value, old);\n    }\n};\n\nexport const [_currentTrackLength, _setCurrentTrackLength] = makePersisted(\n    createSignal<number>(0, { equals: false }),\n    {\n        name: `player.v1.currentTrackLength`,\n    },\n);\nconst onCurrentTrackLengthChangedListener =\n    createListener<\n        (\n            value: ReturnType<typeof _currentTrackLength>,\n            old: ReturnType<typeof _currentTrackLength>,\n        ) => boolean | void\n    >();\nexport const onCurrentTrackLengthChanged =\n    onCurrentTrackLengthChangedListener.on;\nexport const offCurrentTrackLengthChanged =\n    onCurrentTrackLengthChangedListener.off;\nexport const currentTrackLength = _currentTrackLength;\nexport const setCurrentTrackLength = (\n    value: Parameters<typeof _setCurrentTrackLength>[0],\n    trigger = true,\n) => {\n    const old = _currentTrackLength();\n    if (typeof value === 'function') {\n        value = value(old);\n    }\n    _setCurrentTrackLength(value);\n    if (trigger && value !== old) {\n        onCurrentTrackLengthChangedListener.trigger(value, old);\n    }\n};\n\nexport const [currentAlbum, setCurrentAlbum] = makePersisted(\n    createSignal<Album | Track | undefined>(undefined, {\n        equals: false,\n    }),\n    {\n        name: `player.v2.currentAlbum`,\n    },\n);\n\nexport const [_playlistPosition, _setPlaylistPosition] = makePersisted(\n    createSignal<number | undefined>(undefined, { equals: false }),\n    { name: `player.v1.playlistPosition` },\n);\nconst onPlaylistPositionChangedListener =\n    createListener<\n        (\n            value: ReturnType<typeof _playlistPosition>,\n            old: ReturnType<typeof _playlistPosition>,\n        ) => boolean | void\n    >();\nexport const onPlaylistPositionChanged = onPlaylistPositionChangedListener.on;\nexport const offPlaylistPositionChanged = onPlaylistPositionChangedListener.off;\nexport const playlistPosition = _playlistPosition;\nexport const setPlaylistPosition = (\n    value: Parameters<typeof _setPlaylistPosition>[0],\n    trigger = true,\n) => {\n    const old = _playlistPosition();\n    if (typeof value === 'function') {\n        value = value(old);\n    }\n    _setPlaylistPosition(value);\n    if (trigger && value !== old) {\n        onPlaylistPositionChangedListener.trigger(value, old);\n    }\n};\n\nconst [_playlist, _setPlaylist] = makePersisted(\n    createSignal<Track[]>([], { equals: false }),\n    { name: `player.v1.playlist` },\n);\nconst onPlaylistChangedListener =\n    createListener<\n        (\n            value: ReturnType<typeof _playlist>,\n            old: ReturnType<typeof _playlist>,\n        ) => boolean | void\n    >();\nexport const onPlaylistChanged = onPlaylistChangedListener.on;\nexport const offPlaylistChanged = onPlaylistChangedListener.off;\nexport const playlist = _playlist;\nexport const setPlaylist = (\n    value: Parameters<typeof _setPlaylist>[0],\n    trigger = true,\n) => {\n    const old = _playlist();\n    if (typeof value === 'function') {\n        value = value(old);\n    }\n    _setPlaylist(value);\n    if (trigger) {\n        onPlaylistChangedListener.trigger(value, old);\n    }\n};\n\nexport interface PlayerType {\n    id: number;\n    activate?(): boolean | void | Promise<boolean | void>;\n    deactivate?(): boolean | void | Promise<boolean | void>;\n    updatePlayback(\n        update: PlaybackUpdate,\n    ): boolean | void | Promise<boolean | void>;\n}\n\nconst playListener = createListener<() => void>();\nexport const onPlay = playListener.on;\nexport const offPlay = playListener.off;\n\nexport function isMasterPlayer(zone: Api.AudioZone | undefined): boolean {\n    const activeZonePlayers = getActiveZonePlayers(zone);\n\n    console.debug(\n        'isMasterPlayer:',\n        'zone:',\n        zone,\n        'players:',\n        players,\n        'activeZonePlayers:',\n        activeZonePlayers,\n    );\n\n    if (activeZonePlayers.length === 0) {\n        console.debug('isMasterPlayer: no active zone players');\n        return false;\n    }\n\n    const first = activeZonePlayers[0];\n\n    if (zone?.players.findIndex((p) => p.playerId === first?.id) !== 0) {\n        console.debug('isMasterPlayer: player is not first');\n        return false;\n    }\n\n    console.debug('isMasterPlayer: player is master');\n    return true;\n}\n\nexport function getActiveZonePlayers(\n    zone: Api.AudioZone | undefined,\n): PlayerType[] {\n    console.debug('getActiveZonePlayers: zone =', zone, 'players =', players);\n    return (\n        players.filter((p) => zone?.players.some((x) => p.id === x.playerId)) ??\n        []\n    );\n}\n\nexport function isActiveConnectionPlayer(\n    playbackTarget: Api.ConnectionOutputPlaybackTarget,\n): boolean {\n    const players = getActiveConnectionPlayers(\n        appState.connection,\n        playbackTarget,\n    );\n\n    return players.length === 1;\n}\n\nexport function getActiveConnectionPlayers(\n    connection: Api.Connection | undefined,\n    playbackTarget: Api.ConnectionOutputPlaybackTarget,\n): PlayerType[] {\n    console.debug(\n        'getActiveConnectionPlayers: connection =',\n        connection,\n        'players =',\n        players,\n    );\n\n    if (connection?.connectionId !== playbackTarget.connectionId) {\n        return [];\n    }\n\n    return (\n        players.filter((p) =>\n            connection?.players.some(\n                (x) =>\n                    p.id === x.playerId &&\n                    x.audioOutputId === playbackTarget.outputId,\n            ),\n        ) ?? []\n    );\n}\n\nexport async function play() {\n    console.debug('Play called');\n    await updatePlayback({ playing: true });\n}\n\nconst seekListener = createListener<(seek: number, manual: boolean) => void>();\nexport const onSeek = seekListener.on;\nexport const offSeek = seekListener.off;\n\nexport async function seek(seek: number, manual = false) {\n    console.debug('Seek called');\n    if (typeof seek === 'number' && manual) {\n        console.debug(`Setting seek to ${seek}`);\n        await updatePlayback({ play: playing(), seek });\n    }\n    seekListener.trigger(seek, manual);\n}\n\nconst pauseListener = createListener<() => void>();\nexport const onPause = pauseListener.on;\nexport const offPause = pauseListener.off;\n\nexport async function pause() {\n    console.debug('Pause called');\n    await updatePlayback({ playing: false });\n}\n\nconst prevTrackListener = createListener<TrackListenerCallback>();\nexport const onPreviousTrack = prevTrackListener.on;\nexport const offPreviousTrack = prevTrackListener.off;\n\nexport async function previousTrack(): Promise<boolean> {\n    if (playlistPosition() === 0) {\n        console.debug('Setting track position to 0');\n        seek(0, true);\n    } else if ((currentSeek() ?? 0) < 5) {\n        console.debug('Playing previous track');\n\n        const position = playlistPosition() ?? 0;\n\n        await updatePlayback({\n            play: true,\n            seek: 0,\n            position: position > 0 ? position - 1 : position,\n        });\n    } else {\n        console.debug('Setting track position to 0');\n        seek(0, true);\n    }\n    return false;\n}\n\nconst nextTrackListener = createListener<TrackListenerCallback>();\nexport const onNextTrack = nextTrackListener.on;\nexport const offNextTrack = nextTrackListener.off;\n\nexport async function nextTrack(): Promise<boolean> {\n    if (\n        typeof playlistPosition() === 'number' &&\n        playlistPosition()! < playlist()!.length - 1\n    ) {\n        console.debug('Playing next track');\n\n        const position = playlistPosition() ?? 0;\n\n        await updatePlayback({\n            play: true,\n            seek: 0,\n            position: position + 1,\n        });\n    } else {\n        console.debug('No next track to play');\n        stop();\n    }\n\n    return false;\n}\n\nconst stopListener = createListener<() => void>();\nexport const onStop = stopListener.on;\nexport const offStop = stopListener.off;\n\nexport async function stop() {\n    await updatePlayback({ stop: false });\n}\n\nconst playAlbumListener = createListener<() => void>();\nexport const onPlayAlbum = playAlbumListener.on;\nexport const offPlayAlbum = playAlbumListener.off;\n\nexport async function playAlbum(album: Album | Track) {\n    console.debug('playAlbum', album);\n    setCurrentAlbum(album);\n\n    const albumType = 'type' in album ? album.type : 'TRACK';\n\n    switch (albumType) {\n        case 'LIBRARY': {\n            album = album as Api.LibraryAlbum;\n            const versions = await api.getAlbumVersions(album.albumId);\n            const tracks = versions[0]!.tracks;\n            await playPlaylist(tracks);\n            break;\n        }\n        case 'TRACK': {\n            album = album as Api.LibraryTrack;\n            const versions = await api.getAlbumVersions(album.albumId);\n            const tracks = versions[0]!.tracks;\n            await playPlaylist(tracks);\n            break;\n        }\n        case 'TIDAL': {\n            album = album as Api.TidalAlbum;\n            const page = await api.getTidalAlbumTracks(album.id);\n            const tracks = page.items;\n            await playPlaylist(tracks);\n            break;\n        }\n        case 'QOBUZ': {\n            album = album as Api.QobuzAlbum;\n            const page = await api.getQobuzAlbumTracks(album.id);\n            const tracks = page.items;\n            await playPlaylist(tracks);\n            break;\n        }\n        case 'YT': {\n            album = album as Api.YtAlbum;\n            const page = await api.getYtAlbumTracks(album.id);\n            const tracks = page.items;\n            await playPlaylist(tracks);\n            break;\n        }\n        default:\n            albumType satisfies never;\n            throw new Error(`Invalid album type '${albumType}'`);\n    }\n}\n\nconst playPlaylistListener = createListener<() => void>();\nexport const onPlayPlaylist = playPlaylistListener.on;\nexport const offPlayPlaylist = playPlaylistListener.off;\n\nexport async function playPlaylist(tracks: Track[]) {\n    console.debug('playPlaylist', tracks);\n    const firstTrack = tracks[0];\n    setCurrentAlbum(firstTrack);\n\n    await updatePlayback({\n        play: true,\n        position: 0,\n        seek: 0,\n        tracks,\n        quality: playbackQuality(),\n    });\n}\n\nconst addAlbumToQueueListener = createListener<() => void>();\nexport const onAddAlbumToQueue = addAlbumToQueueListener.on;\nexport const offAddAlbumToQueue = addAlbumToQueueListener.off;\n\nexport async function addAlbumToQueue(album: Album | Track) {\n    console.debug('addAlbumToQueue', album);\n\n    const albumType = 'type' in album ? album.type : 'TRACK';\n\n    switch (albumType) {\n        case 'LIBRARY': {\n            album = album as Api.LibraryAlbum;\n            const versions = await api.getAlbumVersions(album.albumId);\n            const tracks = versions[0]!.tracks;\n            return addTracksToQueue(tracks);\n        }\n        case 'TRACK': {\n            album = album as Api.LibraryTrack;\n            const versions = await api.getAlbumVersions(album.albumId);\n            const tracks = versions[0]!.tracks;\n            return addTracksToQueue(tracks);\n        }\n        case 'TIDAL': {\n            album = album as Api.TidalAlbum;\n            const page = await api.getTidalAlbumTracks(album.id);\n            const tracks = page.items;\n            return addTracksToQueue(tracks);\n        }\n        case 'QOBUZ': {\n            album = album as Api.QobuzAlbum;\n            const page = await api.getQobuzAlbumTracks(album.id);\n            const tracks = page.items;\n            return addTracksToQueue(tracks);\n        }\n        case 'YT': {\n            album = album as Api.YtAlbum;\n            const page = await api.getYtAlbumTracks(album.id);\n            const tracks = page.items;\n            return addTracksToQueue(tracks);\n        }\n        default:\n            albumType satisfies never;\n            throw new Error(`Invalid album type '${albumType}'`);\n    }\n}\n\nexport async function addTracksToQueue(tracks: Track[]) {\n    console.debug('addTracksToQueue', tracks);\n    updatePlayback({\n        tracks: [...playlist(), ...tracks],\n    });\n}\n\nexport function removeTrackFromPlaylist(index: number) {\n    console.debug('Removing track from playlist', index);\n\n    const update: Parameters<typeof updatePlayback>[0] = {\n        tracks: [...playlist()!.filter((_, i) => i !== index)],\n    };\n\n    const currentPosition = playlistPosition()!;\n\n    if (index < currentPosition) {\n        update.position = currentPosition - 1;\n    } else if (index === currentPosition) {\n        update.seek = 0;\n        update.play = true;\n    }\n\n    updatePlayback(update);\n}\n\nexport function playFromPlaylistPosition(index: number) {\n    console.debug('Playing from playlist position', index);\n    updatePlayback({ play: true, position: index, seek: 0 });\n}\n\nexport const players: PlayerType[] = [];\n\nexport function containsPlayer(id: number): boolean {\n    return players.some((p) => p.id === id);\n}\n\nexport function registerPlayer(player: PlayerType) {\n    if (players.find((p) => p.id === player.id)) {\n        console.debug('Player already registered', player);\n        return;\n    }\n    console.debug('Registering player', player);\n\n    players.push(player);\n}\n\nexport function sessionUpdated(update: PartialUpdateSession) {\n    const playbackTarget = update.playbackTarget;\n    const playbackTargetType = playbackTarget.type;\n\n    switch (playbackTargetType) {\n        case 'AUDIO_ZONE':\n            {\n                if (\n                    !isMasterPlayer(\n                        playerState.audioZones.find(\n                            (z) => z.id === playbackTarget.audioZoneId,\n                        ),\n                    )\n                ) {\n                    handlePlaybackUpdate(update);\n                    console.debug('Not master player. Returning');\n                    return;\n                }\n            }\n            break;\n        case 'CONNECTION_OUTPUT':\n            if (!isActiveConnectionPlayer(playbackTarget)) {\n                handlePlaybackUpdate(update);\n                console.debug('Not active connection player. Returning');\n                return;\n            }\n            break;\n        default:\n            playbackTargetType satisfies never;\n            throw new Error(\n                `Invalid playbackTargetType: '${playbackTargetType}'`,\n            );\n    }\n\n    const sessionId = update.sessionId;\n\n    const playbackUpdate: PlaybackUpdate = {\n        sessionId,\n        playbackTarget,\n    };\n\n    for (const [key, value] of orderedEntries(update, [\n        'play',\n        'stop',\n        'playing',\n        'playlist',\n        'position',\n        'seek',\n        'volume',\n    ])) {\n        if (typeof value === 'undefined') continue;\n\n        switch (key) {\n            case 'play':\n                playbackUpdate.play = value;\n                break;\n            case 'stop':\n                playbackUpdate.stop = value;\n                break;\n            case 'playing':\n                playbackUpdate.playing = value;\n                break;\n            case 'playlist':\n                playbackUpdate.tracks = value?.tracks;\n                break;\n            case 'position':\n                playbackUpdate.position = value;\n                break;\n            case 'seek':\n                playbackUpdate.seek = value;\n                break;\n            case 'volume':\n                playbackUpdate.volume = value;\n                break;\n            case 'quality':\n                playbackUpdate.quality = value;\n                break;\n            case 'active':\n            case 'name':\n            case 'sessionId':\n            case 'playbackTarget':\n                break;\n            default:\n                key satisfies never;\n        }\n    }\n\n    updatePlayback(playbackUpdate, false);\n}\n\nasync function confirmChangePlaybackTarget() {\n    showChangePlaybackTargetModal.set(true);\n\n    // eslint-disable-next-line no-async-promise-executor\n    return new Promise(async (resolve) => {\n        resolve(await responsePromise());\n    });\n}\n\nexport type PlaybackUpdate = {\n    sessionId: number;\n    playbackTarget: Api.PlaybackTarget;\n    play?: boolean;\n    stop?: boolean;\n    playing?: boolean;\n    quality?: Api.PlaybackQuality;\n    position?: number;\n    seek?: number;\n    volume?: number;\n    tracks?: Track[];\n};\n\nasync function updatePlayback(\n    update: Omit<PlaybackUpdate, 'sessionId' | 'playbackTarget'>,\n    updateSession = true,\n) {\n    if (!update.quality) {\n        update.quality = playbackQuality();\n    }\n\n    const playbackUpdate = update as PlaybackUpdate;\n    const sessionId = playbackUpdate.sessionId ?? currentPlaybackSessionId();\n    const session = playerState.playbackSessions.find(\n        (x) => x.sessionId === sessionId,\n    );\n    let playbackTarget = playbackUpdate.playbackTarget;\n    const currentTarget = currentPlaybackTarget();\n    let useDefaultPlaybackTarget = false;\n\n    if (session) {\n        playbackTarget = session.playbackTarget;\n\n        if (\n            currentTarget &&\n            !deepEqual(currentTarget, session.playbackTarget) &&\n            !session.playing &&\n            (update.playing || update.play) &&\n            (await confirmChangePlaybackTarget())\n        ) {\n            useDefaultPlaybackTarget = true;\n        }\n    }\n\n    if (useDefaultPlaybackTarget) {\n        if (currentTarget) {\n            playbackTarget = currentTarget;\n        }\n    }\n\n    if (updateSession) {\n        const sessionUpdate: Parameters<typeof updatePlaybackSession>[1] = {\n            sessionId,\n            playbackTarget,\n        };\n\n        for (const [key, value] of orderedEntries(update, [\n            'play',\n            'playing',\n            'position',\n            'seek',\n            'volume',\n            'tracks',\n            'quality',\n        ])) {\n            if (typeof value === 'undefined') continue;\n\n            switch (key) {\n                case 'play':\n                    sessionUpdate.play = value;\n                    if (update.play) {\n                        sessionUpdate.playing = true;\n                    }\n                    break;\n                case 'stop':\n                    sessionUpdate.stop = value;\n                    break;\n                case 'playing':\n                    sessionUpdate.playing = value;\n                    break;\n                case 'position':\n                    sessionUpdate.position = value;\n                    break;\n                case 'seek':\n                    sessionUpdate.seek = value;\n                    break;\n                case 'volume':\n                    sessionUpdate.volume = value;\n                    break;\n                case 'tracks':\n                    sessionUpdate.playlist = {\n                        tracks: value,\n                    };\n                    break;\n                case 'quality':\n                    sessionUpdate.quality = value;\n                    break;\n                default:\n                    key satisfies never;\n            }\n        }\n\n        updatePlaybackSession(sessionId, sessionUpdate);\n    }\n\n    const activePlayers = [];\n    const playbackTargetType = playbackTarget.type;\n\n    switch (playbackTargetType) {\n        case 'AUDIO_ZONE':\n            activePlayers.push(\n                ...getActiveZonePlayers(\n                    playerState.audioZones.find(\n                        ({ id }) => id === playbackTarget.audioZoneId,\n                    ),\n                ),\n            );\n            break;\n        case 'CONNECTION_OUTPUT':\n            activePlayers.push(\n                ...getActiveConnectionPlayers(\n                    appState.connection,\n                    playbackTarget,\n                ),\n            );\n            break;\n        default:\n            playbackTargetType satisfies never;\n            throw new Error(\n                `Invalid playbackTargetType: '${playbackTargetType}'`,\n            );\n    }\n\n    console.debug('activePlayers:', activePlayers);\n\n    await updateActivePlayers(activePlayers, {\n        ...update,\n        sessionId,\n        playbackTarget,\n    });\n}\n\nasync function updateActivePlayers(\n    activePlayers: PlayerType[],\n    update: PlaybackUpdate,\n) {\n    if (activePlayers.length === 0) {\n        handlePlaybackUpdate(update);\n    } else {\n        stopSilence();\n    }\n\n    await Promise.all(\n        activePlayers.map((activePlayer) =>\n            activePlayer.updatePlayback(update),\n        ),\n    );\n}\n\nfunction handlePlaybackUpdate(update: PlaybackUpdate) {\n    for (const [key, value] of orderedEntries(update, [\n        'stop',\n        'volume',\n        'seek',\n        'play',\n        'tracks',\n        'position',\n        'playing',\n        'quality',\n    ])) {\n        if (typeof value === 'undefined') continue;\n\n        switch (key) {\n            case 'stop':\n                if (update.play || update.playing) continue;\n                if (navigator.mediaSession) {\n                    navigator.mediaSession.playbackState = 'paused';\n                }\n                break;\n            case 'playing':\n                if (update.play) continue;\n                if (navigator.mediaSession) {\n                    navigator.mediaSession.playbackState = update.playing\n                        ? 'playing'\n                        : 'paused';\n                }\n                if (update.playing) {\n                    return startSilence();\n                }\n                break;\n            case 'play':\n                if (!isSilencePlaying()) {\n                    return startSilence();\n                }\n                if (navigator.mediaSession) {\n                    navigator.mediaSession.playbackState = 'playing';\n                }\n                break;\n            case 'seek':\n                if (typeof update.seek === 'number') {\n                    navigator.mediaSession?.setPositionState({\n                        position: update.seek,\n                        duration: currentTrackLength(),\n                    });\n                }\n                break;\n            case 'volume':\n            case 'quality':\n            case 'tracks':\n            case 'position':\n            case 'sessionId':\n            case 'playbackTarget':\n                break;\n            default:\n                key satisfies never;\n        }\n    }\n\n    const session = playerState.playbackSessions.find(\n        (session) => session.sessionId === update.sessionId,\n    );\n\n    if (session?.playing) {\n        if (!isSilencePlaying()) {\n            return startSilence();\n        }\n    }\n}\n\nfunction updatePlaybackSession(\n    id: number,\n    request: Omit<PartialBy<PartialUpdateSession, 'playlist'>, 'playlist'> & {\n        playlist?: PartialBy<\n            Omit<Api.UpdatePlaybackSessionPlaylist, 'tracks'>,\n            'sessionPlaylistId'\n        > & { tracks: Track[] };\n    },\n) {\n    console.debug('updatePlaybackSession:', id, request);\n    setPlayerState(\n        produce((state) => {\n            const current = state.currentPlaybackSession;\n            const session =\n                current?.sessionId === id\n                    ? current\n                    : state.playbackSessions.find((s) => s.sessionId === id);\n            if (session) {\n                const { playlist } = session;\n                if (playlist && request.playlist) {\n                    request.playlist.sessionPlaylistId =\n                        playlist.sessionPlaylistId;\n                }\n                updateSessionPartial(state, request as PartialUpdateSession);\n\n                const updatePlaybackSession: Api.UpdatePlaybackSession = {\n                    ...request,\n                    playlist: undefined,\n                } as unknown as Api.UpdatePlaybackSession;\n\n                if (request.playlist) {\n                    updatePlaybackSession.playlist = {\n                        ...request.playlist,\n                        sessionPlaylistId: request.playlist.sessionPlaylistId!,\n                        tracks: request.playlist.tracks.map(\n                            toSessionPlaylistTrack,\n                        ),\n                    };\n\n                    console.debug(\n                        'updatePlaybackSession: playlist:',\n                        updatePlaybackSession.playlist,\n                    );\n                } else {\n                    delete updatePlaybackSession.playlist;\n                }\n\n                wsService.updateSession(updatePlaybackSession);\n            }\n        }),\n    );\n}\n\nconst onCurrentPlaybackSessionChangedListener =\n    createListener<\n        (\n            value: PlayerState['currentPlaybackSession'],\n            old: PlayerState['currentPlaybackSession'],\n        ) => boolean | void\n    >();\nexport const onCurrentPlaybackSessionChanged =\n    onCurrentPlaybackSessionChangedListener.on;\nexport const offCurrentPlaybackSessionChanged =\n    onCurrentPlaybackSessionChangedListener.off;\n\nconst onUpdateSessionPartialListener =\n    createListener<(value: PartialUpdateSession) => boolean | void>();\nexport const onUpdateSessionPartial = onUpdateSessionPartialListener.on;\nexport const offUpdateSessionPartial = onUpdateSessionPartialListener.off;\n\nexport function updateSessionPartial(\n    state: PlayerState,\n    session: PartialUpdateSession,\n) {\n    state.playbackSessions.forEach((s) => {\n        if (s.sessionId === session.sessionId) {\n            Object.assign(s, session);\n        }\n    });\n\n    if (state.currentPlaybackSession?.sessionId === session.sessionId) {\n        Object.assign(state.currentPlaybackSession, session);\n\n        let updatedPlaylist = false;\n\n        if (typeof session.seek !== 'undefined') {\n            _setCurrentSeek(session.seek);\n        }\n        if (typeof session.position !== 'undefined') {\n            _setPlaylistPosition(session.position);\n            updatedPlaylist = true;\n        }\n        if (typeof session.playlist !== 'undefined') {\n            _setPlaylist(session.playlist.tracks);\n            updatedPlaylist = true;\n        }\n\n        if (updatedPlaylist) {\n            if (typeof playlistPosition() === 'number') {\n                const track =\n                    state.currentPlaybackSession.playlist.tracks[\n                        playlistPosition()!\n                    ];\n\n                if (track) {\n                    state.currentTrack = track;\n                    setCurrentTrackLength(Math.round(track.duration));\n                }\n            } else {\n                state.currentTrack = undefined;\n                setCurrentTrackLength(0);\n            }\n        }\n    }\n\n    onUpdateSessionPartialListener.trigger(session);\n}\n\nexport function updateSession(\n    state: PlayerState,\n    session: Api.PlaybackSession,\n    setAsCurrent = false,\n) {\n    state.playbackSessions.forEach((s) => {\n        if (s.sessionId === session.sessionId) {\n            Object.assign(s, session);\n        }\n    });\n\n    if (\n        setAsCurrent ||\n        session.sessionId === state.currentPlaybackSession?.sessionId\n    ) {\n        const old = state.currentPlaybackSession;\n        state.currentPlaybackSession = session;\n        setCurrentPlaybackSessionId(session.sessionId);\n\n        console.debug('session changed to', session, 'from', old);\n\n        _setPlaylist(session.playlist.tracks);\n        _setCurrentSeek(session.seek);\n        _setPlaylistPosition(\n            session.playlist.tracks.length > 0 ? session.position : undefined,\n        );\n\n        if (typeof playlistPosition() === 'number') {\n            const track = session.playlist.tracks[playlistPosition()!];\n\n            if (track) {\n                state.currentTrack = track;\n                setCurrentTrackLength(Math.round(track.duration));\n            }\n        } else {\n            state.currentTrack = undefined;\n            setCurrentTrackLength(0);\n        }\n\n        onCurrentPlaybackSessionChangedListener.trigger(session, old);\n    }\n}\n\nonCurrentSeekChanged((value, old) => {\n    console.debug('current seek changed from', old, 'to', value);\n    if (typeof value === 'number') {\n        navigator.mediaSession?.setPositionState({\n            position: value,\n            duration: currentTrackLength(),\n        });\n    }\n    const activeZonePlayer = playerState.audioZones.some((zone) =>\n        isMasterPlayer(zone),\n    );\n    const playbackTarget = currentPlaybackTarget();\n    if (\n        activeZonePlayer ||\n        (playbackTarget?.type === 'CONNECTION_OUTPUT' &&\n            isActiveConnectionPlayer(playbackTarget))\n    ) {\n        updatePlayback({ seek: value ?? 0 });\n    }\n});\n\nonUpdateSessionPartial((session) => {\n    if (playerState.currentPlaybackSession?.sessionId !== session.sessionId) {\n        return;\n    }\n\n    if (typeof session.seek !== 'undefined') {\n        _setCurrentSeek(session.seek);\n    }\n});\n\nexport function playing(): boolean {\n    return playerState.currentPlaybackSession?.playing ?? false;\n}\n\nif (!isServer) {\n    if (navigator?.mediaSession) {\n        onCurrentPlaybackSessionChanged((value) => {\n            navigator.mediaSession.playbackState = value?.playing\n                ? 'playing'\n                : 'paused';\n            console.debug(\n                'updated playback state to',\n                navigator.mediaSession.playbackState,\n            );\n        });\n        navigator.mediaSession.setActionHandler('play', () => {\n            console.log('mediaSession: play');\n            play();\n        });\n        navigator.mediaSession.setActionHandler('pause', () => {\n            console.log('mediaSession: pause');\n            if (navigator.mediaSession.playbackState === 'playing') {\n                pause();\n            } else {\n                play();\n            }\n        });\n        navigator.mediaSession.setActionHandler('stop', () => {\n            console.log('mediaSession: stop');\n            stop();\n        });\n        navigator.mediaSession.setActionHandler('nexttrack', () => {\n            console.log('mediaSession: nexttrack');\n            nextTrack();\n        });\n        navigator.mediaSession.setActionHandler('previoustrack', () => {\n            console.log('mediaSession: previoustrack');\n            previousTrack();\n        });\n    }\n\n    document.body.onkeydown = function (e) {\n        const target = e.target as HTMLElement;\n\n        if (\n            !(target instanceof HTMLInputElement) &&\n            (e.key == ' ' || e.code == 'Space')\n        ) {\n            if (playerState.currentPlaybackSession?.playing || playing()) {\n                pause();\n            } else {\n                play();\n            }\n            e.preventDefault();\n        }\n    };\n}\n","import { createStore, produce } from 'solid-js/store';\nimport { Api, api } from './api';\nimport { createListener } from './util';\nimport { onStartup } from './app';\n\nexport type DownloadEventType =\n    | BytesReadDownloadEvent['type']\n    | SizeDownloadEvent['type']\n    | SpeedDownloadEvent['type']\n    | StateDownloadEvent['type'];\n\nexport type BytesReadDownloadEvent = {\n    taskId: number;\n    read: number;\n    total: number;\n    type: 'BYTES_READ';\n};\n\nexport type SizeDownloadEvent = {\n    taskId: number;\n    bytes?: number;\n    type: 'SIZE';\n};\n\nexport type SpeedDownloadEvent = {\n    taskId: number;\n    bytesPerSecond: number;\n    type: 'SPEED';\n};\n\nexport type StateDownloadEvent = {\n    taskId: number;\n    state: Api.DownloadTaskState;\n    type: 'STATE';\n};\n\nexport type DownloadEvent = (\n    | BytesReadDownloadEvent\n    | SizeDownloadEvent\n    | SpeedDownloadEvent\n    | StateDownloadEvent\n) & { type: DownloadEventType };\n\nexport const onDownloadEventListener =\n    createListener<(value: DownloadEvent) => boolean | void>();\nexport const onDownloadEvent = onDownloadEventListener.on;\nexport const offDownloadEvent = onDownloadEventListener.off;\n\ninterface DownloadsState {\n    tasks: Api.DownloadTask[];\n    currentTasks: Api.DownloadTask[];\n    historyTasks: Api.DownloadTask[];\n}\n\nexport const [downloadsState, setDownloadsState] = createStore<DownloadsState>({\n    tasks: [],\n    currentTasks: [],\n    historyTasks: [],\n});\n\nfunction handleDownloadEvent(event: DownloadEvent) {\n    const eventType = event.type;\n\n    switch (eventType) {\n        case 'SIZE':\n            setDownloadsState(\n                produce((state) => {\n                    const task = state.tasks.find(\n                        (task) => task.id === event.taskId,\n                    );\n                    if (task) {\n                        task.totalBytes = event.bytes ?? task.totalBytes;\n                    }\n                }),\n            );\n            break;\n        case 'BYTES_READ':\n            setDownloadsState(\n                produce((state) => {\n                    const task = state.tasks.find(\n                        (task) => task.id === event.taskId,\n                    );\n                    if (task) {\n                        task.bytes = event.total;\n                        task.progress = (event.total / task.totalBytes) * 100;\n                    }\n                }),\n            );\n            break;\n        case 'SPEED':\n            setDownloadsState(\n                produce((state) => {\n                    const task = state.tasks.find(\n                        (task) => task.id === event.taskId,\n                    );\n                    if (task) {\n                        task.speed = event.bytesPerSecond;\n                    }\n                }),\n            );\n            break;\n        case 'STATE':\n            setDownloadsState(\n                produce((state) => {\n                    const task = state.tasks.find(\n                        (task) => task.id === event.taskId,\n                    );\n                    if (task) {\n                        const prevState = task.state;\n                        task.state = event.state;\n\n                        if (isCurrent(task.state) && !isCurrent(prevState)) {\n                            const index = state.historyTasks.indexOf(task);\n                            if (index !== -1) {\n                                state.historyTasks.splice(index, 1);\n                            }\n                            state.currentTasks.unshift(task);\n                        } else if (\n                            !isCurrent(task.state) &&\n                            isCurrent(prevState)\n                        ) {\n                            const index = state.currentTasks.indexOf(task);\n                            if (index !== -1) {\n                                state.currentTasks.splice(index, 1);\n                            }\n                            state.historyTasks.unshift(task);\n                        }\n\n                        if (task.state === 'FINISHED') {\n                            task.progress = 100;\n                        }\n                    }\n                }),\n            );\n            break;\n        default:\n            eventType satisfies never;\n            throw new Error(`Invalid DownloadEvent type: '${eventType}'`);\n    }\n}\n\nonDownloadEvent(handleDownloadEvent);\n\nfunction isCurrent(state: Api.DownloadTaskState): boolean {\n    return state === 'STARTED' || state === 'PAUSED' || state === 'PENDING';\n}\n\nfunction isHistorical(state: Api.DownloadTaskState): boolean {\n    return !isCurrent(state);\n}\n\nonStartup(async () => {\n    const tasks = await api.getDownloadTasks();\n\n    const current = tasks.items.filter(({ state }) => isCurrent(state));\n    const history = tasks.items.filter(({ state }) => isHistorical(state));\n\n    setDownloadsState(\n        produce((state) => {\n            state.tasks = tasks.items;\n            state.currentTasks = current;\n            state.historyTasks = history;\n        }),\n    );\n});\n","import { createStore, produce } from 'solid-js/store';\nimport { ScanOrigin } from './api';\nimport { createListener, deepEqual } from './util';\nimport { onStartup, showScanStatusBanner } from './app';\n\nexport type ScanEventType =\n    | FinishedScanEvent['type']\n    | CountScanEvent['type']\n    | ScannedScanEvent['type'];\n\nexport type FinishedScanEvent = {\n    task: ScanTask;\n    scanned: number;\n    total: number;\n    type: 'FINISHED';\n};\n\nexport type CountScanEvent = {\n    task: ScanTask;\n    scanned: number;\n    total: number;\n    type: 'COUNT';\n};\n\nexport type ScannedScanEvent = {\n    task: ScanTask;\n    scanned: number;\n    total: number;\n    type: 'SCANNED';\n};\n\nexport type ScanEvent = (\n    | FinishedScanEvent\n    | CountScanEvent\n    | ScannedScanEvent\n) & { type: ScanEventType };\n\nexport type ScanTask = LocalScanTask['type'] | ApiScanTask['type'];\n\nexport type LocalScanTask = {\n    paths: string[];\n    type: 'LOCAL';\n};\n\nexport type ApiScanTask = {\n    paths: ScanOrigin;\n    type: 'API';\n};\n\nexport const onScanEventListener =\n    createListener<(value: ScanEvent) => boolean | void>();\nexport const onScanEvent = onScanEventListener.on;\nexport const offScanEvent = onScanEventListener.off;\n\ninterface ScansState {\n    tasks: {\n        task: ScanTask;\n        scanned: number;\n        total: number;\n    }[];\n}\n\nexport const [scanState, setScansState] = createStore<ScansState>({\n    tasks: [],\n});\n\nfunction handleScanEvent(event: ScanEvent) {\n    const eventType = event.type;\n\n    switch (eventType) {\n        case 'FINISHED':\n            setScansState(\n                produce((state) => {\n                    const task = state.tasks.find((task) =>\n                        deepEqual(task.task, event.task),\n                    );\n                    if (task) {\n                        task.scanned = event.scanned;\n                        task.total = event.total;\n                    }\n                }),\n            );\n            setTimeout(() => {\n                setScansState(\n                    produce((state) => {\n                        state.tasks = state.tasks.filter(\n                            (task) => !deepEqual(task.task, event.task),\n                        );\n                    }),\n                );\n\n                if (scanState.tasks.length === 0) {\n                    showScanStatusBanner.set(false);\n                }\n            }, 5000);\n            break;\n        case 'COUNT':\n            setScansState(\n                produce((state) => {\n                    const task = state.tasks.find((task) =>\n                        deepEqual(task.task, event.task),\n                    );\n                    if (task) {\n                        task.scanned = event.scanned;\n                        task.total = event.total;\n                    } else {\n                        state.tasks.push({\n                            task: event.task,\n                            scanned: event.scanned,\n                            total: event.total,\n                        });\n                    }\n                }),\n            );\n            showScanStatusBanner.set(true);\n            break;\n        case 'SCANNED':\n            setScansState(\n                produce((state) => {\n                    const task = state.tasks.find((task) =>\n                        deepEqual(task.task, event.task),\n                    );\n                    if (task) {\n                        task.scanned = event.scanned;\n                        task.total = event.total;\n                    } else {\n                        state.tasks.push({\n                            task: event.task,\n                            scanned: event.scanned,\n                            total: event.total,\n                        });\n                    }\n                }),\n            );\n            showScanStatusBanner.set(true);\n            break;\n        default:\n            eventType satisfies never;\n            throw new Error(`Invalid ScanEvent type: '${eventType}'`);\n    }\n}\n\nonScanEvent(handleScanEvent);\n\nonStartup(async () => {\n    setScansState(\n        produce((state) => {\n            state.tasks = [];\n        }),\n    );\n});\n","import * as player from './player';\nimport { produce } from 'solid-js/store';\nimport { Api, connection, toSessionPlaylistTrack } from './api';\nimport type { Track } from './api';\nimport { setAppState } from './app';\nimport type { PartialUpdateSession } from './types';\nimport { clientAtom, createListener, objToStr } from './util';\nimport { onDownloadEventListener } from './downloads';\nimport type { DownloadEvent } from './downloads';\nimport { onScanEventListener, ScanEvent } from './scan';\n\nconnection.listen((con) => {\n    if (!con) return;\n\n    updateWsUrl(\n        con.apiUrl,\n        con.clientId,\n        Api.signatureToken(),\n        con.staticToken,\n    );\n    if (con.token && !Api.signatureToken()) {\n        console.debug('Waiting for signature token');\n        return;\n    }\n    wsService.reconnect();\n});\nApi.onSignatureTokenUpdated((signatureToken) => {\n    const con = connection.get();\n    if (!con) return;\n\n    updateWsUrl(con.apiUrl, con.clientId, signatureToken, con.staticToken);\n    if (con.token && !signatureToken) {\n        console.debug('Waiting for signature token');\n        return;\n    }\n    wsService.reconnect();\n});\n\nfunction updateWsUrl(\n    apiUrl: string,\n    clientId: string | undefined,\n    signatureToken: string | undefined,\n    staticToken: string | undefined,\n) {\n    if (!apiUrl?.startsWith('http')) return;\n\n    const params = [];\n    if (clientId) {\n        params.push(`clientId=${encodeURIComponent(clientId)}`);\n    }\n    if (signatureToken) {\n        params.push(`signature=${encodeURIComponent(signatureToken)}`);\n    }\n    if (staticToken) {\n        params.push(`authorization=${encodeURIComponent(staticToken)}`);\n    }\n    wsUrl = `ws${apiUrl.slice(4)}/ws${\n        params.length > 0 ? `?${params.join('&')}` : ''\n    }`;\n}\n\nlet ws: WebSocket;\nlet wsUrl: string;\nexport let connectionPromise: Promise<WebSocket>;\n\nexport const connectionId = clientAtom<string>('', 'ws.v1.connectionId');\nconst $connectionId = () => connectionId.get();\n\nexport const connectionName = clientAtom<string>(\n    'New Connection',\n    'ws.v1.connectionName',\n);\n\nexport const onConnectListener =\n    createListener<\n        (value: string) => boolean | void | Promise<boolean | void>\n    >();\nexport const onConnect = onConnectListener.on;\nexport const offConnect = onConnectListener.off;\n\nonConnect((id) => {\n    if (!$connectionId()) {\n        connectionId.set(id);\n    }\n    wsService.getSessions();\n});\n\nexport enum InboundMessageType {\n    CONNECTION_ID = 'CONNECTION_ID',\n    SESSIONS = 'SESSIONS',\n    SESSION_UPDATED = 'SESSION_UPDATED',\n    CONNECTIONS = 'CONNECTIONS',\n    SET_SEEK = 'SET_SEEK',\n    DOWNLOAD_EVENT = 'DOWNLOAD_EVENT',\n    SCAN_EVENT = 'SCAN_EVENT',\n}\n\nexport enum OutboundMessageType {\n    PING = 'PING',\n    GET_CONNECTION_ID = 'GET_CONNECTION_ID',\n    PLAYBACK_ACTION = 'PLAYBACK_ACTION',\n    GET_SESSIONS = 'GET_SESSIONS',\n    CREATE_SESSION = 'CREATE_SESSION',\n    UPDATE_SESSION = 'UPDATE_SESSION',\n    DELETE_SESSION = 'DELETE_SESSION',\n    REGISTER_CONNECTION = 'REGISTER_CONNECTION',\n    REGISTER_PLAYERS = 'REGISTER_PLAYERS',\n    CREATE_AUDIO_ZONE = 'CREATE_AUDIO_ZONE',\n    SET_SEEK = 'SET_SEEK',\n}\n\nexport interface ConnectionIdMessage extends InboundMessage {\n    connectionId: string;\n    type: InboundMessageType.CONNECTION_ID;\n}\n\nexport interface SessionsMessage extends InboundMessage {\n    type: InboundMessageType.SESSIONS;\n    payload: Api.PlaybackSession[];\n}\n\nexport interface ConnectionsMessage extends InboundMessage {\n    type: InboundMessageType.CONNECTIONS;\n    payload: Api.Connection[];\n}\n\nexport interface SessionUpdatedMessage extends InboundMessage {\n    type: InboundMessageType.SESSION_UPDATED;\n    payload: PartialUpdateSession;\n}\n\nexport interface SetSeek {\n    sessionId: number;\n    playbackTarget: Api.PlaybackTarget;\n    seek: number;\n}\n\nexport interface SetSeekInboundMessage extends InboundMessage {\n    type: InboundMessageType.SET_SEEK;\n    payload: SetSeek;\n}\n\nexport interface DownloadEventInboundMessage extends InboundMessage {\n    type: InboundMessageType.DOWNLOAD_EVENT;\n    payload: DownloadEvent;\n}\n\nexport interface ScanEventInboundMessage extends InboundMessage {\n    type: InboundMessageType.SCAN_EVENT;\n    payload: ScanEvent;\n}\n\nexport interface GetConnectionIdMessage extends OutboundMessage {\n    type: OutboundMessageType.GET_CONNECTION_ID;\n}\n\nexport interface PingMessage extends OutboundMessage {\n    type: OutboundMessageType.PING;\n}\n\nexport type RegisterConnection = Omit<Api.Connection, 'players' | 'alive'> & {\n    players: RegisterPlayer[];\n};\nexport interface RegisterConnectionMessage extends OutboundMessage {\n    type: OutboundMessageType.REGISTER_CONNECTION;\n    payload: RegisterConnection;\n}\n\nexport type RegisterPlayer = Omit<Api.Player, 'playerId'>;\nexport interface RegisterPlayersMessage extends OutboundMessage {\n    type: OutboundMessageType.REGISTER_PLAYERS;\n    payload: RegisterPlayer[];\n}\n\nexport enum PlaybackAction {\n    PLAY = 'PLAY',\n    PAUSE = 'PAUSE',\n    STOP = 'STOP',\n    NEXT_TRACK = 'NEXT_TRACK',\n    PREVIOUS_TRACK = 'PREVIOUS_TRACK',\n}\n\nexport interface PlaybackActionMessage extends OutboundMessage {\n    type: OutboundMessageType.PLAYBACK_ACTION;\n    payload: {\n        action: PlaybackAction;\n    };\n}\n\nexport interface GetSessionsMessage extends OutboundMessage {\n    type: OutboundMessageType.GET_SESSIONS;\n}\n\nexport interface CreateAudioZoneMessage extends OutboundMessage {\n    type: OutboundMessageType.CREATE_AUDIO_ZONE;\n    payload: CreateAudioZoneRequest;\n}\n\nexport interface CreateAudioZoneRequest {\n    name: string;\n}\n\nexport interface CreateSessionRequest {\n    name: string;\n    playlist: CreateSessionPlaylistRequest;\n    playbackTarget: Api.PlaybackTarget | undefined;\n}\n\nexport interface CreateSessionPlaylistRequest {\n    tracks: Track[];\n}\n\nexport interface CreateSession {\n    name: string;\n    playlist: CreateSessionPlaylist;\n}\n\nexport interface CreateSessionPlaylist {\n    tracks: Api.UpdateSessionPlaylistTrack[];\n}\n\nexport interface CreateSessionMessage extends OutboundMessage {\n    type: OutboundMessageType.CREATE_SESSION;\n    payload: CreateSession;\n}\n\nexport interface UpdateSessionMessage extends OutboundMessage {\n    type: OutboundMessageType.UPDATE_SESSION;\n    payload: Api.UpdatePlaybackSession;\n}\n\nexport interface DeleteSessionMessage extends OutboundMessage {\n    type: OutboundMessageType.DELETE_SESSION;\n    payload: { sessionId: number };\n}\n\nexport interface InboundMessage {\n    type: InboundMessageType;\n}\n\nexport interface OutboundMessage {\n    type: OutboundMessageType;\n}\n\nexport const onMessageListener =\n    createListener<\n        (\n            message: InboundMessage,\n        ) => boolean | void | Promise<boolean> | Promise<void>\n    >();\nexport const onMessage = onMessageListener.on;\nexport const onMessageFirst = onMessageListener.onFirst;\nexport const offMessage = onMessageListener.off;\n\nonMessageFirst((data) => {\n    console.debug('Received ws message', data);\n    switch (data.type) {\n        case InboundMessageType.CONNECTION_ID: {\n            const message = data as ConnectionIdMessage;\n            onConnectListener.trigger(message.connectionId);\n            break;\n        }\n        case InboundMessageType.SESSIONS: {\n            const message = data as SessionsMessage;\n            player.setPlayerState(\n                produce((state) => {\n                    state.playbackSessions = message.payload;\n                    const existing = message.payload.find(\n                        (p) =>\n                            p.sessionId ===\n                            state.currentPlaybackSession?.sessionId,\n                    );\n                    if (existing) {\n                        player.updateSession(state, existing);\n                    } else if (\n                        typeof player.currentPlaybackSessionId() === 'number'\n                    ) {\n                        const session =\n                            message.payload.find(\n                                (s) =>\n                                    s.sessionId ===\n                                    player.currentPlaybackSessionId(),\n                            ) ?? message.payload[0];\n                        if (session) {\n                            player.updateSession(state, session, true);\n                        }\n                    } else {\n                        player.updateSession(state, message.payload[0]!, true);\n                    }\n                }),\n            );\n            break;\n        }\n        case InboundMessageType.CONNECTIONS: {\n            const message = data as ConnectionsMessage;\n            setAppState(\n                produce((state) => {\n                    state.connections = message.payload;\n                    state.connection = state.connections.find(\n                        (c) => c.connectionId === connectionId.get(),\n                    );\n                }),\n            );\n            break;\n        }\n        case InboundMessageType.SET_SEEK: {\n            const message = data as SetSeekInboundMessage;\n            if (\n                message.payload.sessionId ===\n                player.playerState.currentPlaybackSession?.sessionId\n            ) {\n                player.seek(message.payload.seek);\n            }\n            break;\n        }\n        case InboundMessageType.DOWNLOAD_EVENT: {\n            const message = data as DownloadEventInboundMessage;\n            onDownloadEventListener.trigger(message.payload);\n            break;\n        }\n        case InboundMessageType.SCAN_EVENT: {\n            const message = data as ScanEventInboundMessage;\n            onScanEventListener.trigger(message.payload);\n            break;\n        }\n        case InboundMessageType.SESSION_UPDATED: {\n            const message = data as SessionUpdatedMessage;\n\n            const session = message.payload;\n\n            player.setPlayerState(\n                produce((state) => {\n                    player.updateSessionPartial(state, session);\n                }),\n            );\n            player.sessionUpdated(session);\n\n            break;\n        }\n    }\n});\n\nconst MAX_CONNECTION_RETRY_COUNT: number = -1;\nconst CONNECTION_RETRY_DEBOUNCE = 5000;\n\nconst wsContext: {\n    lastConnectionAttemptTime: number;\n    messageBuffer: OutboundMessage[];\n} = {\n    lastConnectionAttemptTime: 0,\n    messageBuffer: [],\n};\n\nexport const wsService = {\n    ping() {\n        this.send<PingMessage>({ type: OutboundMessageType.PING });\n    },\n\n    getConnectionId() {\n        this.send<GetConnectionIdMessage>({\n            type: OutboundMessageType.GET_CONNECTION_ID,\n        });\n    },\n\n    registerConnection(connection: RegisterConnection) {\n        this.send<RegisterConnectionMessage>({\n            type: OutboundMessageType.REGISTER_CONNECTION,\n            payload: connection,\n        });\n    },\n\n    registerPlayers(players: RegisterPlayer[]) {\n        this.send<RegisterPlayersMessage>({\n            type: OutboundMessageType.REGISTER_PLAYERS,\n            payload: players,\n        });\n    },\n\n    playbackAction(action: PlaybackAction) {\n        this.send<PlaybackActionMessage>({\n            type: OutboundMessageType.PLAYBACK_ACTION,\n            payload: {\n                action,\n            },\n        });\n    },\n\n    createAudioZone(audioZone: CreateAudioZoneRequest) {\n        this.send<CreateAudioZoneMessage>({\n            type: OutboundMessageType.CREATE_AUDIO_ZONE,\n            payload: {\n                ...audioZone,\n            },\n        });\n    },\n\n    getSessions() {\n        this.send<GetSessionsMessage>({\n            type: OutboundMessageType.GET_SESSIONS,\n        });\n    },\n\n    activateSession(sessionId: number) {\n        this.updateSession({ sessionId, active: true });\n    },\n\n    createSession(session: CreateSessionRequest) {\n        this.send<CreateSessionMessage>({\n            type: OutboundMessageType.CREATE_SESSION,\n            payload: {\n                ...session,\n                playlist: {\n                    ...session.playlist,\n                    tracks: session.playlist.tracks.map(toSessionPlaylistTrack),\n                },\n            },\n        });\n    },\n\n    updateSession(session: Api.UpdatePlaybackSession) {\n        const payload: Api.UpdatePlaybackSession = {\n            ...session,\n            playlist: undefined,\n        } as unknown as Api.UpdatePlaybackSession;\n\n        if (session.playlist) {\n            payload.playlist = {\n                ...session.playlist,\n            };\n        } else {\n            delete payload.playlist;\n        }\n\n        this.send<UpdateSessionMessage>({\n            type: OutboundMessageType.UPDATE_SESSION,\n            payload,\n        });\n    },\n\n    deleteSession(sessionId: number) {\n        this.send<DeleteSessionMessage>({\n            type: OutboundMessageType.DELETE_SESSION,\n            payload: {\n                sessionId,\n            },\n        });\n    },\n\n    send<T extends OutboundMessage>(value: T) {\n        if (ws) {\n            console.debug('Sending WebSocket message', value);\n            ws.send(JSON.stringify(value));\n        } else {\n            console.debug('Adding WebSocket message to buffer', value);\n            wsContext.messageBuffer.push(value);\n        }\n    },\n\n    newClient(): Promise<void> {\n        return new Promise((resolve, reject) => {\n            console.log('connecting to ', wsUrl);\n            const client = new WebSocket(wsUrl);\n\n            let pingInterval: NodeJS.Timeout | undefined;\n            let opened = false;\n\n            client.addEventListener('error', (e: Event) => {\n                console.error('WebSocket client error', e);\n                if (!opened) {\n                    client.close();\n                    reject();\n                }\n            });\n\n            client.addEventListener('open', (_e: Event) => {\n                const wasOpened = opened;\n                opened = true;\n                if (!wasOpened) {\n                    pingInterval = setInterval(\n                        () => {\n                            if (!opened) return clearInterval(pingInterval);\n\n                            this.ping();\n                        },\n                        9 * 60 * 1000,\n                    );\n\n                    ws = client;\n\n                    while (wsContext.messageBuffer.length > 0) {\n                        const value = wsContext.messageBuffer.shift();\n                        console.debug(\n                            'Sending buffered WebSocket message',\n                            value,\n                        );\n                        ws.send(JSON.stringify(value));\n                    }\n\n                    this.getConnectionId();\n                    resolve();\n                }\n            });\n\n            client.addEventListener(\n                'message',\n                (event: MessageEvent<string>) => {\n                    const data = JSON.parse(event.data) as InboundMessage;\n                    onMessageListener.trigger(data);\n                },\n            );\n\n            client.addEventListener('close', async () => {\n                if (opened) {\n                    console.debug('Closed WebSocket connection');\n                    opened = false;\n                    client.close();\n                    clearInterval(pingInterval);\n\n                    const now = Date.now();\n                    if (wsContext.lastConnectionAttemptTime + 5000 > now) {\n                        console.debug(\n                            `Debouncing connection retry attempt. Waiting ${CONNECTION_RETRY_DEBOUNCE}ms`,\n                        );\n                        await this.sleep(CONNECTION_RETRY_DEBOUNCE);\n                    }\n                    wsContext.lastConnectionAttemptTime = now;\n                    await this.attemptConnection();\n                } else {\n                    reject();\n                }\n            });\n        });\n    },\n\n    async sleep(ms: number): Promise<void> {\n        return new Promise((resolve) => {\n            setTimeout(resolve, ms);\n        });\n    },\n\n    async attemptConnection(): Promise<void> {\n        let attemptNumber = 0;\n\n        // eslint-disable-next-line no-constant-condition\n        while (true) {\n            console.debug(\n                `Attempting connection${\n                    attemptNumber > 0 ? `, Attempt ${attemptNumber + 1}` : ''\n                }`,\n            );\n\n            try {\n                await this.newClient();\n\n                console.debug('Successfully connected client');\n\n                return;\n            } catch (e: unknown) {\n                if (\n                    attemptNumber++ === MAX_CONNECTION_RETRY_COUNT &&\n                    MAX_CONNECTION_RETRY_COUNT !== -1\n                ) {\n                    break;\n                }\n\n                console.error(\n                    `WebSocket connection failed at '${wsUrl}':`,\n                    objToStr(e),\n                );\n                console.debug(\n                    `Failed to connect. Waiting ${CONNECTION_RETRY_DEBOUNCE}ms`,\n                );\n                await this.sleep(CONNECTION_RETRY_DEBOUNCE);\n            }\n        }\n\n        throw new Error('Failed to establish connection to websocket server');\n    },\n\n    reconnect(): Promise<void> {\n        if (ws) ws.close();\n\n        return this.attemptConnection();\n    },\n};\n"],"names":["clientAtom","showAudioZones","showPlaybackSessions","showPlaybackQuality","showChangePlaybackTargetModal","showScanStatusBanner","getStartupCallbacks","isStartedUp","setStartedUp","value","onStartup","func","e","triggerStartup","appState","setAppState","createStore","currentArtistSearch","setCurrentArtistSearch","createSignal","currentAlbumSearch","setCurrentAlbumSearch","connection","con","prev","api","zones","setPlayerState","produce","state","current","currentPlaybackTarget","existing","x","setCurrentPlaybackTarget","modalFunc","props","_$createComponent","Show","when","show","children","_el$","_$getNextElement","_tmpl$","_el$2","firstChild","_$addEventListener","onClose","$$click","stopPropagation","_$insert","_c$","_$memo","_$effect","_$className","class","_$runHydrationEvents","_$delegateEvents","responsePromiseResolves","responsePromise","Promise","resolve","push","changePlaybackTargetModalFunc","$showChangePlaybackTargetModal","clientSignal","_tmpl$2","Modal","set","_el$3","_el$4","_el$5","nextSibling","_el$6","_el$7","_el$8","_el$9","stopImmediatePropagation","forEach","tryingToPlay","audio","initSilence","query","QueryParams","Api","getConnection","clientIdParam","signatureToken","url","isSilencePlaying","startSilence","stopSilence","playerState","_playbackQuality","_setPlaybackQuality","makePersisted","onPlaybackQualityChangedListener","createListener","playbackQuality","setPlaybackQuality","trigger","old","updatePlayback","_currentPlaybackTarget","_setCurrentPlaybackTarget","onCurrentPlaybackTargetChangedListener","currentPlaybackSessionId","setCurrentPlaybackSessionId","setVolume","volume","_currentSeek","_setCurrentSeek","onCurrentSeekChangedListener","onCurrentSeekChanged","currentSeek","setCurrentSeek","_currentTrackLength","_setCurrentTrackLength","onCurrentTrackLengthChangedListener","currentTrackLength","setCurrentTrackLength","currentAlbum","setCurrentAlbum","_playlistPosition","_setPlaylistPosition","playlistPosition","_playlist","_setPlaylist","playlist","isMasterPlayer","zone","activeZonePlayers","getActiveZonePlayers","players","first","p","isActiveConnectionPlayer","playbackTarget","getActiveConnectionPlayers","play","seekListener","onSeek","offSeek","seek","manual","playing","pause","prevTrackListener","onPreviousTrack","offPreviousTrack","previousTrack","position","nextTrackListener","onNextTrack","offNextTrack","nextTrack","stop","playAlbum","album","albumType","tracks","playPlaylist","firstTrack","addAlbumToQueue","addTracksToQueue","removeTrackFromPlaylist","index","update","_","i","currentPosition","playFromPlaylistPosition","registerPlayer","player","sessionUpdated","playbackTargetType","z","handlePlaybackUpdate","playbackUpdate","key","orderedEntries","confirmChangePlaybackTarget","updateSession","sessionId","session","currentTarget","useDefaultPlaybackTarget","deepEqual","sessionUpdate","updatePlaybackSession","activePlayers","id","updateActivePlayers","activePlayer","request","s","updateSessionPartial","toSessionPlaylistTrack","wsService","onCurrentPlaybackSessionChangedListener","onCurrentPlaybackSessionChanged","onUpdateSessionPartialListener","onUpdateSessionPartial","updatedPlaylist","track","setAsCurrent","activeZonePlayer","onDownloadEventListener","onDownloadEvent","downloadsState","setDownloadsState","handleDownloadEvent","event","eventType","task","prevState","isCurrent","isHistorical","tasks","history","onScanEventListener","onScanEvent","scanState","setScansState","handleScanEvent","updateWsUrl","apiUrl","clientId","staticToken","params","wsUrl","ws","connectionId","$connectionId","connectionName","onConnectListener","onConnect","InboundMessageType","onMessageListener","onMessage","onMessageFirst","data","message","player.setPlayerState","player.updateSession","player.currentPlaybackSessionId","c","player.playerState","player.seek","player.updateSessionPartial","player.sessionUpdated","MAX_CONNECTION_RETRY_COUNT","CONNECTION_RETRY_DEBOUNCE","wsContext","action","audioZone","payload","reject","client","pingInterval","opened","_e","wasOpened","now","ms","attemptNumber","objToStr"],"mappings":"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"}